[{"id":"6b11c3b4174be8f0fe049e7a3fa727bd","title":"博客简述","content":"这个博客将被我用作笔记和题记以及听课笔记，也是我做的第一个博客，如果有需要可以通过概览中的洛谷以及CSDN联系到我，或者联系我的QQ：1075506339 也可以。笔记中如有错误，敬请雅正，如有疑惑，欢迎讨论，如有补充，您的宝贵意见将会是我的莫大荣幸。如果我的笔记或是题解对您有所启发，也欢迎小额打赏。\n我可能引用的资源来源于：Acwing性价比极高的编程、算法学习平台，讲解仔细全面，拥有在线编译器，以及丰富的题库及编程经验\n\n洛谷拥有即为广泛的题目，我用作刷题网站，也会去发布一些观点、解题思路和题解\n\n力扣相较于洛谷，力扣更侧重于面试，里面同样拥有丰富的题库，与洛谷混合食用\n\n牛客另外一个倾向于面试，有着很高知名度的网站，有着许多有趣的题目，同时许多校赛、训练赛、月赛在牛客举办\n\nCodeforcescf线上赛有着很高的知名度，题目质量很高，知识点即为全面\n\nAtcoder同样是高质量的线上赛网站\n\nVirtual Judgevj的库十分丰富，很多高校的训练也在此展开\n\nCSDN想必这个也不用什么介绍罢\n\n","slug":"博客简述","date":"3000-10-28T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"SMTTY"},{"id":"64cc41e6615c26a6a66bf8b1da23ea06","title":"树状数据结构整理","content":"","slug":"树状数据结构整理","date":"2023-01-07T14:59:58.221Z","categories_index":"","tags_index":"","author_index":"SMTTY"},{"id":"e0aa9ca13b84c518e471c68dfb7b2c45","title":"线段树整理","content":"","slug":"线段树整理","date":"2023-01-01T16:00:00.000Z","categories_index":"整理,线段树","tags_index":"线段树,整理","author_index":"SMTTY"},{"id":"1a48202df2aea416252e5097dc1ec408","title":"A.Stop, Yesterday Please No More","content":"链接：测试链接中文题面在这里面找\n题目大意：给定一张n行m列的网格，在位于ih行jh列的格子上有且仅有一个洞，其他每个格子上都是空地且都有一只袋鼠。全部袋鼠被U,D,L,R控制，所有袋鼠会同时根据按下的按键移动，对于一只位于第i行j列的格子上的袋鼠(用(i, j)表示)：\n\nU：它会移动到(i - 1, j)；\nD：它会移动到(i + 1, j)；\nL：它会移动到(i, j - 1)；\nR：它会移动到(i, j + 1)。\n\n如果一只袋鼠踩到了洞或者移动到了网格外面，它将被从网格移除。给出网格n*m，一个整数k，以及一系列操作(由’U’,’D’,’L’,’R’组成)；问网格中可能存在洞的位置有多少个，使得一系列操作后，网格内恰有k只袋鼠存留。数据范围：第一行三个整数n,m,k：1 ≤ n,m ≤ 103，0 ≤ k &lt; n * m;第二行一个字符串表示一系列操作，且长度≤106。\n分析思路：题非常简单，首先考虑到，如果洞不存在，那么一系列操作进行后，如果袋鼠还有剩余一定是一个矩阵；为了确定剩余袋鼠的矩阵，我们对上下左右四个(UDLR)边界分别设置一个临时变量，每次操作后，对左上边界与临时变量取max值，对右下取min值即可确定剩余矩阵的边界，在这个过程中，以L操作为例，L操作后袋鼠整体向左移，相对而言就是边界向右移，此时应该是左右边界的临时值分别++；确定完剩余的袋鼠之后，我们需要判断一下上下以及左右边界是否合法（如果上边界&lt;下边界，或左边界&gt;有边界，则说明没有剩余袋鼠），此时结合k值进行讨论，如果k&#x3D;0，场上任意位置均可以有洞，输出n * m，如果k≠0，则说明哪个位置存在洞都不能满足剩余k只袋鼠的条件，因为他们都出网格了，输出0。上面特殊情况考虑完之后，我们轻松的得到，没有出网格的袋鼠数量为x &#x3D; (D - U + 1) * (R - L + 1)，因为最终要剩余k只袋鼠，那么将有(x - k)只袋鼠应当掉入洞中，则我们需要统计每个格子有多少只不同的袋鼠经过过，最终记录值(x - k)的格子数量；对于这个操作我们很容易就想到二维差分，我们通过模拟剩余的袋鼠的矩阵，每次将这个矩阵范围的格子++（记得初始矩阵也要统计），由于矩阵的大小已经是唯一确定的了，我们只需要开一个二维布尔数组统计左上(或右下)是否已经计过数，就可以很轻松的判重了，最后再用二维前缀和统计出答案输出即可。这个题应该很容易A掉吧…\n代码如下：#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\n#define endl &#39;\\n&#39;\n\nconst int N &#x3D; 1010;\n\nstring op;\n\nint n, m, k;\nint U, D, L, R, U_, D_, L_, R_;\nbool st[N][N];\nint g[N][N];\n\nvoid add(int x1, int y1, int x2, int y2)&#123;\n    if (st[x1][y1])\n        return;\n    st[x1][y1] &#x3D; true;\n    g[x1][y1]++, g[x2 + 1][y1]--, g[x1][y2 + 1]--, g[x2 + 1][y2 + 1]++;\n&#125;\n\nvoid solve()&#123;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; op;\n    U_ &#x3D; L_ &#x3D; U &#x3D; L &#x3D; 1, R_ &#x3D; R &#x3D; m, D_ &#x3D; D &#x3D; n;\n    memset(st, false, sizeof st), memset(g, 0, sizeof g);\n    &#x2F;&#x2F;确定边界\n    for (auto i: op)&#123;\n        if (i &#x3D;&#x3D; &#39;L&#39;)\n            L_++, R_++;\n        else if (i &#x3D;&#x3D; &#39;R&#39;)\n            L_--, R_--;\n        else if (i &#x3D;&#x3D; &#39;U&#39;)\n            U_++, D_++;\n        else\n            U_--, D_--;\n        L &#x3D; max(L, L_), R &#x3D; min(R, R_), U &#x3D; max(U, U_), D &#x3D; min(D, D_);\n    &#125;\n    &#x2F;&#x2F;无袋鼠剩余情况\n    if (U &gt; D || L &gt; R)&#123;\n        if (k)\n            puts(&quot;0&quot;);\n        else\n            cout &lt;&lt; n * m &lt;&lt; endl;\n        return;\n    &#125;\n    &#x2F;&#x2F;统计袋鼠经过格子的情况\n    int x &#x3D; (D - U + 1) * (R - L + 1), cnt &#x3D; 0;\n    add(U, L, D, R);\n    for (auto i: op)&#123;\n        if (i &#x3D;&#x3D; &#39;L&#39;)\n            L--, R--;\n        else if (i &#x3D;&#x3D; &#39;R&#39;)\n            L++, R++;\n        else if (i &#x3D;&#x3D; &#39;U&#39;)\n            U--, D--;\n        else\n            U++, D++;\n        add(U, L, D, R);\n    &#125;\n    &#x2F;&#x2F;二位前缀和+统计答案\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )\n            g[i][j] +&#x3D; g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1];\n\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )\n            if (x - g[i][j] &#x3D;&#x3D; k)\n                 cnt++;\n    cout &lt;&lt; cnt &lt;&lt; endl;\n&#125;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )\n        solve();\n&#125;","slug":"2022icpcnanjingA.Stop, Yesterday Please No More","date":"2023-01-31T10:19:13.343Z","categories_index":"题记,icpc,The 2022 ICPC Asia Nanjing Regional Contest,差分","tags_index":"题记,icpc,The 2022 ICPC Asia Nanjing Regional Contest,差分","author_index":"SMTTY"},{"id":"8b78cc765c53e033e18243f7d6ac7be7","title":"D.Chat Program","content":"链接：测试链接中文题面在这里面找\n题目大意：题面很长，说人话就是，给一个长n的序列a，另外给出k,m,c,d四个整数，我们可以选择序列中的一个位置p(1 ≤ p ≤ n - m + 1)，并对于所有0 ≤ i &lt; m，将ap+i增加(c + di)，求至多进行一次操作后，序列中第k大的值最大可能为多少。数据范围：1 ≤ k, m ≤ n ≤ 2 × 105，0 ≤ c, d ≤ 109，0 ≤ ai ≤ 109。输入格式：第一行五个整数：n, k, m, c, d；第二行n个整数ai。\n分析思路：说实话，看到第k大，俺就想平衡树，结果呢，是个二分…首先，答案是唯一确定的，并且根据数据范围一定属于[0, 1018] (其实应该比1018要小,但这样更保险)，我们二分的根据就是可以讲这个区间划分为小于等于答案和大于答案两部分。从时间复杂度上我们不难看出，如果写二分的话，那么check中的时间复杂度应该是O(n)的，显然很难想…因为这个A搞了个差分，所以就不免往差分和前缀和这里去想了，结果还真能做；首先check返回true时表示传入的mid小于等于答案，即在最优的位置加上这个等差数列之后，大于等于mid的数的个数大于等于k，反之则为false；扫描一遍序列a，如果ai≥mid则cnt++，反之，尝试寻找一段有效区间(指首项允许加在的位置上)使得首项加在该区间任意位置后，可以使得该项大于等于mid，而记录这个区间，我们采用差分的方式，即构造一个差分数组s，令区间[l, r]的左s[l]++,右s[r + 1]–，这样再重新扫描一遍就可以得到，当等差数列加在最优位置后，可以多出多少个大于mid的数，再加上原来的cnt，最后与k比较，这样就线性的完成了这项工作。然后这个题就可以A掉了吧…\n代码如下：#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n\ntypedef long long ll;\n\nconst int N &#x3D; 200010;\nconst ll MAX &#x3D; 1e18;\n\nint n, k, m;\nll c, d;\nll a[N];\nint s[N];\n\nbool check(ll x)&#123;\n    for (int i &#x3D; 0; i &lt;&#x3D; n + 1; i ++ )\n        s[i] &#x3D; 0;\n    int cnt &#x3D; 0, l, r;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (a[i] &gt;&#x3D; x)\n            cnt++;\n        else&#123;\n            &#x2F;&#x2F;首项最远的位置\n            l &#x3D; i - m + 1;\n            &#x2F;&#x2F;寻找右边界\n            if (d !&#x3D; 0)\n                r &#x3D; std::min(int(i - ceil(double(x - a[i] - c) &#x2F; d)), i);\n            else if (a[i] + c &gt;&#x3D; x)\n                r &#x3D; i;\n            else\n                r &#x3D; -0x3f3f3f3f;\n            &#x2F;&#x2F;如果区间存在则记录，如果l&gt;r表示数列最大项加上也不够\n            if (l &lt;&#x3D; r)\n                s[std::max(1, l)]++, s[std::max(0, r) + 1]--;\n        &#125;\n    \n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n        s[i] +&#x3D; s[i - 1];\n        if (s[i] + cnt &gt;&#x3D; k)\n            return true;\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d%d%lld%lld&quot;, &amp;n, &amp;k, &amp;m, &amp;c, &amp;d);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        scanf(&quot;%lld&quot;, &amp;a[i]);\n\n    ll l &#x3D; 0, r &#x3D; MAX, mid;\n    while (l &lt; r)&#123;\n        mid &#x3D; l + r + 1 &gt;&gt; 1;\n        if (check(mid))\n            l &#x3D; mid;\n        else\n            r &#x3D; mid - 1;\n    &#125;\n\n    printf(&quot;%lld\\n&quot;, l);\n&#125;","slug":"2022icpcnanjingD.Chat Program","date":"2023-01-27T10:44:57.940Z","categories_index":"题记,icpc,The 2022 ICPC Asia Nanjing Regional Contest,差分,二分答案","tags_index":"题记,icpc,The 2022 ICPC Asia Nanjing Regional Contest,差分,二分答案","author_index":"SMTTY"},{"id":"8f6e4acfe4f50e2d7064f00009cb5c10","title":"CF240F.TorCoder","content":"原题链接：CF240F\n题目大意：给出一个长度为n的由’a’到’z’组成的字符串，有m次操作，每次操作将[l, r]这些位置的字符进行重排，得到字典序最小的回文字符串，如果无法组成回文字符串，则操作不进行，输出操作m次后的字符串。输入输出要求：从文件 input.txt 中读入数据，输出到文件 output.txt 中。数据范围：1 ≤ n,m ≤ 105，1 ≤ l ≤ r ≤ n。\n分析思路：代码如下：#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nchar a[N];\nstruct Node&#123;\n    int l, r;\n    int tag;\n    int t[26];\n&#125; tr[N * 4];\n&#x2F;&#x2F;将u节点全部更新为c\ninline void update(int u, int c)&#123;\n    memset(tr[u].t, 0, sizeof tr[u].t);\n    tr[u].t[c] &#x3D; tr[u].r - tr[u].l + 1;\n    tr[u].tag &#x3D; c;\n&#125;\n\ninline void pushup(int u)&#123;\n    for (int i &#x3D; 0; i &lt; 26; i ++ )\n        tr[u].t[i] &#x3D; tr[u &lt;&lt; 1].t[i] + tr[u &lt;&lt; 1 | 1].t[i];\n&#125;\n\ninline void pushdown(int u)&#123;\n    if (tr[u].tag &#x3D;&#x3D; -1) return;\n    update(u &lt;&lt; 1, tr[u].tag);\n    update(u &lt;&lt; 1 | 1, tr[u].tag);\n    tr[u].tag &#x3D; -1;\n&#125;\n\nvoid build(int u, int l, int r)&#123;\n    tr[u] &#x3D; &#123;l, r, -1&#125;;\n    if (l &#x3D;&#x3D; r)&#123;\n        tr[u].t[a[l] - &#39;a&#39;]++;\n        tr[u].tag &#x3D; a[l] - &#39;a&#39;;\n        return;\n    &#125;\n    int mid &#x3D; l + r &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n    pushup(u);\n&#125;\n\nvoid modify(int u, int l, int r, int c)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        update(u, c);\n    else&#123;\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        pushdown(u);\n        if (l &lt;&#x3D; mid)\n            modify(u &lt;&lt; 1, l, r, c);\n        if (r &gt; mid)\n            modify(u &lt;&lt; 1 | 1, l, r, c);\n        pushup(u);\n    &#125;\n&#125;\n\nvoid query(int cnt[], int u, int l, int r)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        for (int i &#x3D; 0; i &lt; 26; i ++ )\n            cnt[i] +&#x3D; tr[u].t[i];\n    else&#123;\n        pushdown(u);\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        if (l &lt;&#x3D; mid)\n            query(cnt, u &lt;&lt; 1, l, r);\n        if (r &gt; mid)\n            query(cnt, u &lt;&lt; 1 | 1, l, r);\n    &#125;\n&#125;\n\nvoid operate()&#123;\n    int l, r;\n    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);\n    int len &#x3D; r - l + 1, odd &#x3D; 0, p &#x3D; -1, cnt[26] &#x3D; &#123;&#125;;\n    query(cnt, 1, l, r);\n    for (int i &#x3D; 0; i &lt; 26; i ++ )\n        if (cnt[i] &amp; 1)\n            odd++, p &#x3D; i;\n    if ((odd &#x3D;&#x3D; 1) &amp;&amp; (len &amp; 1))&#123;\n        &#x2F;&#x2F;都是奇数\n        int j &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; 26; i ++ )&#123;\n            if (!cnt[i]) continue;\n\n            modify(1, l + j - 1, l + j - 1 + cnt[i] &#x2F; 2, i);\n            modify(1, r - j + 1 - cnt[i] &#x2F; 2, r - j + 1, i);\n            j +&#x3D; cnt[i] &#x2F; 2;\n        &#125;\n        modify(1, l + j - 1, l + j - 1, p);\n    &#125;else if(odd &#x3D;&#x3D; 0 &amp;&amp; ((len ^ 1) &amp; 1))&#123;\n        &#x2F;&#x2F;都是偶数\n        int j &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; 26; i ++ )&#123;\n            if (!cnt[i]) continue;\n\n            modify(1, l + j - 1, l + j - 1 + cnt[i] &#x2F; 2, i);\n            modify(1, r - j + 1 - cnt[i] &#x2F; 2, r - j + 1, i);\n            j +&#x3D; cnt[i] &#x2F; 2;\n        &#125;\n    &#125;\n&#125;\n\nvoid printtree(int u, int l, int r)&#123;\n    if (l &#x3D;&#x3D; r)&#123;\n        printf(&quot;%c&quot;, tr[u].tag + &#39;a&#39;);\n        return;\n    &#125;\n    int mid &#x3D; l + r &gt;&gt; 1;\n    pushdown(u);\n    printtree(u &lt;&lt; 1, l, mid), printtree(u &lt;&lt; 1 | 1, mid + 1, r);\n&#125;\n\nint main()&#123;\n    freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    scanf(&quot;%s&quot;, a + 1);\n\n    build(1, 1, n);\n\n    while (m -- )    \n        operate();\n\n    printtree(1, 1, n);\n&#125;","slug":"CF240F.TorCoder","date":"2023-01-15T15:00:59.763Z","categories_index":"题记,Codeforces,Codeforces Round#145 (Div. 1, ACM-ICPC Rules),D2600,线段树","tags_index":"题记,codeforces,线段树,Codeforces Round#145 (Div. 1, ACM-ICPC Rules),D2600","author_index":"SMTTY"},{"id":"50b31c65d3a0ab42e18780b1693a66e7","title":"CF242E.XOR on Segment","content":"原题链接：CF242E\n题目大意：维护长度为n的序列a，并支持两张操作：\n\n求区间[l, r]的元素和(以op,l,r输入)\n把区间[l, r]的元素分别异或上x(以op,l,r,x输入)输入格式：第一行一个n表示序列长度，第二行是长度为n的序列；第三行m表示操作的个数，接下来m行是操作。数据范围：1 ≤ n ≤ 105，1 ≤ m ≤ 5*104，0 ≤ ai ≤ 106，1 ≤ x ≤ 106。\n\n分析思路：读完题很明显是个线段树，再加上异或运算，我们很容易就想到用二进制去维护每一个元素的值，那么非叶子节点的值应该等于其左右儿子的值之和，不难发现，对于加法，如果我们不进位，转化到十进制，也不会错误的，比方说(10)2+(10)2&#x3D;(100)2&#x3D;4，如果不进位则为(20)以二进制的权位相加结果仍为4，也就是说每个根节点的值可以直接每一位加和(不用考虑进位)得到。再分析区间异或运算，如果某一位上^0 时显然这一位是不变的，而当某一位^1 时相当于这一位上取反，那么对于一个区间的每一个元素的同一个位置上^1 就相当于将该位置的所有0变成1、所有1变成0，换而言之交换该根节点这一位置上01的个数；有个这个结论上传和懒标记也就有了思路，上传即统计每个位置上0和1的和，懒标记则记为0、1需要取反则为1，反之为0(偶数次取反则不用取反，所以懒标记统计也用异或)。对于拆位后的值，我们仍可通过权位相加法得到原值。\n代码如下：#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nint a[N];\nll p[21];\nstruct Node&#123;\n    int l, r;\n    int num[2][20];\n    short tag[20];\n&#125; tr[N * 4];\n&#x2F;&#x2F;tr[u]的第i位取反\ninline void swapnum(int u, int i)&#123;\n    swap(tr[u].num[0][i], tr[u].num[1][i]);\n&#125;\n&#x2F;&#x2F;上传\ninline void pushup(int u)&#123;\n    for (int i &#x3D; 0; i &lt; 20; i ++ )\n        tr[u].num[0][i] &#x3D; tr[u &lt;&lt; 1].num[0][i] + tr[u &lt;&lt; 1 | 1].num[0][i],\n        tr[u].num[1][i] &#x3D; tr[u &lt;&lt; 1].num[1][i] + tr[u &lt;&lt; 1 | 1].num[1][i];\n&#125;\n&#x2F;&#x2F;下放\ninline void pushdown(int u)&#123;\n    for (int i &#x3D; 0; i &lt; 20; i ++ )&#123;\n        if (!tr[u].tag[i])\n            continue;\n        tr[u &lt;&lt; 1].tag[i] ^&#x3D; tr[u].tag[i];\n        tr[u &lt;&lt; 1 | 1].tag[i] ^&#x3D; tr[u].tag[i];\n        swapnum(u &lt;&lt; 1, i), swapnum(u &lt;&lt; 1 | 1, i);\n        tr[u].tag[i] &#x3D; 0;\n    &#125;\n&#125;\n&#x2F;&#x2F;更新\ninline void update(int u, int x)&#123;\n    for (int i &#x3D; 0; i &lt; 20; i ++ )\n        if (x &gt;&gt; i &amp; 1)&#123;\n            tr[u].tag[i] ^&#x3D; 1;\n            swapnum(u, i);\n        &#125;\n&#125;\n&#x2F;&#x2F;求tr[u]的值\ninline ll getnum(int u)&#123;\n    ll res &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; 20; i ++ )\n        res +&#x3D;(ll) p[i] * tr[u].num[1][i];\n    return res;\n&#125;\n\nvoid build(int u, int l, int r)&#123;\n    tr[u] &#x3D; &#123;l, r&#125;;\n    if(l &#x3D;&#x3D; r)&#123;\n        for (int i &#x3D; 0; i &lt; 20; i ++ )\n            tr[u].num[a[l] &gt;&gt; i &amp; 1][i] &#x3D; 1;\n        return;\n    &#125;\n    int mid &#x3D; l + r &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n    pushup(u);\n&#125;\n\nvoid modify(int u, int l, int r, int x)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        update(u, x);\n    else&#123;\n        pushdown(u);\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        if (l &lt;&#x3D; mid) modify(u &lt;&lt; 1, l, r, x);\n        if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, x);\n        pushup(u);\n    &#125;\n&#125;\n\nll query(int u, int l, int r)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        return getnum(u);\n    else&#123;\n        pushdown(u);\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        ll res &#x3D; 0;\n        if (l &lt;&#x3D; mid) res &#x3D; query(u &lt;&lt; 1, l, r);\n        if (r &gt; mid) res +&#x3D; query(u &lt;&lt; 1 | 1, l, r);\n        return res;\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        scanf(&quot;%d&quot;, &amp;a[i]);\n\n    p[0] &#x3D; 1;\n    for (int i &#x3D; 1; i &lt;&#x3D; 20; i ++ )\n        p[i] &#x3D; p[i - 1] * 2;\n\n    build(1, 1, n);\n  \n    scanf(&quot;%d&quot;, &amp;m);\n    int op, l, r, x;\n    while (m -- )&#123;\n        scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r);\n        if (op &#x3D;&#x3D; 1) printf(&quot;%lld\\n&quot;, query(1, l, r));\n        else&#123;\n            scanf(&quot;%d&quot;, &amp;x);\n            modify(1, l, r, x);\n        &#125;\n    &#125;\n&#125;","slug":"CF242E.XOR on Segment","date":"2023-01-14T12:24:15.132Z","categories_index":"题记,Codeforces,Codeforces Round#149 (Div. 2),D2000,线段树","tags_index":"题记,codeforces,D2000,线段树,Codeforces Round#149 (Div. 2)","author_index":"SMTTY"},{"id":"739a4c86892ca932c7b320c540dd8272","title":"洛谷P2802回家","content":"原题链接：LuoguP2802\n题目大意：在一个n*m个方格组成的矩形内，每次可以向上下左右四个方向移动一格，共有五种属性的格子：0. 障碍物（不可行走）\n\n空地\n起点\n终点\n带有治疗效果的空地（除了障碍物均可自由行走）刚开始时是满血6点，每移动一个需要耗费一点生命值以及一个单位时间；如果血量减为0，那么不能到达其他格子，即当血量为1点时，下一步哪怕是终点或者可以治疗生命，也无法到达，记为死亡；带有治疗效果的空地可以将血量补满；问：能否安全到家，如果能，输出最短需要多长时间，如果不能则输出-1；数据范围：1 ≤ n, m ≤ 9。\n\n解题思路：很明显的广搜，跟别的地图题一样；对于广搜的队列中的元素，我们知道到达队头的位置一定小于等于队列中其他位置，那么最短时间等价于最先搜索到3；因为需要维护到达每个点的时间以及血量，我们需要一个结构体方便记录；对于扩列的过程，如果重复到达一个点，而第二次到达时血量更高，那么这种情况也应扩进队列，因为第一次到达该点一定在第二次到达前扩入队列，若能到达终点，则第二次到达无影响，如果不能到达终点，则需要尝试第二次更高血量这种情况，所以需要把标记升级一下，改成上一次到达时的血量，对于严格血量大于的情况我们插入队列，否则不插入，即可解决问题。\n代码如下：#include&lt;iostream&gt;\nusing namespace std;\n\nconst int N &#x3D; 15;\n\nint n, m, sx, sy, ans;\nint g[N][N];\nint st[N][N];\nint fx[4] &#x3D; &#123;0, 0, 1, -1&#125;, fy[4] &#x3D; &#123;1, -1, 0, 0&#125;;\n\nstruct Step&#123;\n    int x, y;\n    int t, hp;&#x2F;&#x2F;记录到达当前点所需时间和剩余血量\n&#125; q[N * N];\n\nvoid bfs()&#123;\n    int hh &#x3D; 0, tt &#x3D; 0;\n    q[0] &#x3D; &#123;sx, sy, 0, 6&#125;;\n\n    while (hh &lt;&#x3D; tt)&#123;\n        Step t &#x3D; q[hh++];\n        if (t.hp &#x3D;&#x3D; 1) continue;&#x2F;&#x2F;血量为1时到不了别的点，直接跳过\n\n        for (int i &#x3D; 0; i &lt; 4; i ++ )&#123;\n            int x &#x3D; t.x + fx[i], y &#x3D; t.y + fy[i];\n            &#x2F;&#x2F;超界不能走\n            if (x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; m)\n                continue;\n            &#x2F;&#x2F;格子0不能走\n            if (!g[x][y]) continue;\n            &#x2F;&#x2F;如果当前血量少于历史到达这点的最大血量则不走\n            if (t.hp - 1 &lt;&#x3D; st[x][y]) continue;\n\n            &#x2F;&#x2F;格子4补满血量\n            if (g[x][y] &#x3D;&#x3D; 4) st[x][y] &#x3D; 6;\n            else st[x][y] &#x3D; t.hp - 1;\n            &#x2F;&#x2F;扩列\n            q[++tt] &#x3D; &#123;x, y, t.t + 1, st[x][y]&#125;;\n            &#x2F;&#x2F;如果到达终点，返回答案\n            if (g[x][y] &#x3D;&#x3D; 3)&#123;\n                ans &#x3D; t.t + 1;\n                return;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n        for (int j &#x3D; 0; j &lt; m; j ++ )&#123;\n            scanf(&quot;%d&quot;, &amp;g[i][j]);\n            if (g[i][j] &#x3D;&#x3D; 2)\n                sx &#x3D; i, sy &#x3D; j;\n        &#125;\n\n    &#x2F;&#x2F;预设答案为-1，如果到不了终点，ans为-1\n    ans &#x3D; -1;\n    bfs();\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;","slug":"洛谷P2802回家","date":"2023-01-11T16:00:00.000Z","categories_index":"题记,洛谷,洛谷橙题,广搜","tags_index":"题记,洛谷,洛谷橙题,广搜","author_index":"SMTTY"},{"id":"f075594e00bebf1a5e02003b274b368e","title":"CF1514D.Cut and Stick","content":"原题链接：CF1514D\n题目大意：给出一个长度为n的序列，可以进行以下操作：\n\n将一些数从原来的区间中剪下来，把这些数重新排成一个或多个区间，最后形成一个或多个区间片段，使得这些区间的所有数恰好是原区间的所有数。\n\n随后给出q次询问，每次询问会给出左右端点，将这个区间分成一个或多个区间片段，使得每个片段内，任意元素出现的次数不严格大于[(x + 1)&#x2F;2]（x表示任意元素出现的次数,[]表示向下取整；即x&#x2F;2向上取整），输出满足条件可以分成的最小片段数。\n数据范围：1 ≤ n,q ≤ 3*105，1≤ ai ≤ n，1 ≤ l ≤ r ≤ n。\n线段树解法：首先说，线段树维护众数是不好维护的，但这个题，我们需要获取的是超过区间长度一半的众数，那也就是说，如果这个区间的众数没有超过区间长度的一半，就可以不用分段，换而言之，此时区间的众数对结果没有任何影响，所以我们只需要维护超过区间长度一半的众数即可。接下来就是用线段树去维护超过区间长度一半的众数：\n\n先考虑如何获取一段区间内某个数字出现的次数，我们可以通过存储每个数字出现的位置，每个数字用一个vector数组去存储，然后用Lower_bound去获取大于等于左端点l的第一个位置，然后再用upper_bound获取大于右端点r的第一个位置，此时，二者的差值就是这个数字在[l, r]内出现的次数，注意右端点处要用upper_bound，因为出现长度的计算原理应该是 出现的最后一次 - 出现的第一次 + 1，而Lower_bound无法判断最后一次出现的位置是恰好在r，还是严格大于r，所以我们只需用upper_bound找到严格大于r的第一次出现，再减去1，即为出现次数。\n其次就是这个题为什么能用线段树做的原因之一，我们所需要维护的是超过区间长度一半的众数，也就是说如果这个区间内。任何数字没有超过区间长度一半的话，那我维护出来的结果不是众数也没有关系；所以线段树的上传操作，仅需比较两儿子的众数，不用考虑可能新产生众数，因为如果新产生的众数不是两儿子任意一个的众数，很容易证得它没有超过区间长度的一半。\n\n超过区间长度一半的众数维护出来之后，就需要对答案计算公式进行推导：\n\n众数小于区间长度一半，则不用分段，答案为1，输出即可。\n众数大于区间长度一半时，设众数为x，除了众数的其他数字为y，区间长度为len，那么len &#x3D; x + y，不难发现每一个y至多消耗2个x，此时我们需要对x,y的关系进行讨论：(1).x &gt;&#x3D; 2y时，即每两个众数和一个其他数配对后，众数仍有剩余，此时剩余的众数每个需要单独一个区间片段，通过计算很容易得到x余&#x3D;len-2y-y&#x3D;len-3y，已经分好的片段数为y，那么区间片段数就是x余+y，将x+y&#x3D;len代入得结果为2x-len；(2).x &lt; 2y时，此时剩余的是除了众数的其他数，不难发现，每一个其他数，可以使两个由2x+y构成的区间合并，通过计算易得y余&#x3D;y - x&#x2F;2，已经分好的片段数为x&#x2F;2，那么区间片段数就应该是x&#x2F;2 - y余，化简得结果仍为2x-len；(没有对x进行奇偶讨论，很容易得出，x无论奇偶，推导出的答案仍为2x-len)综上，我们得出了结果的计算公式，如果众数未超出区间长度的一半，答案为1，如果超出区间长度的一半，答案为2x-len。\n\n线段树代码：#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int N &#x3D; 300010;\n\nvector&lt;int&gt; p[N];\n\nint n, q;\nint w[N];\n\nstruct Node&#123;\n    int l, r;\n    int x;\n&#125; tr[N * 4];\n&#x2F;&#x2F;获取区间[l, r]内x出现的次数，upper_bound的原因解法中有解释\ninline int num(int l, int r, int x)&#123;\n    if (x &#x3D;&#x3D; 0) return 0;\n    return upper_bound(p[x].begin(), p[x].end(), r) -\n           lower_bound(p[x].begin(), p[x].end(), l);\n&#125;\n&#x2F;&#x2F;用于比较节点u左右儿子众数的函数\ninline bool compare(int u)&#123;\n    int lx &#x3D; num(tr[u &lt;&lt; 1].l, tr[u &lt;&lt; 1].r, tr[u &lt;&lt; 1].x),\n        rx &#x3D; num(tr[u &lt;&lt; 1 | 1].l, tr[u &lt;&lt; 1 | 1].r, tr[u &lt;&lt; 1 | 1].x);\n    return lx &gt; rx;\n&#125;\n\ninline void pushup(int u)&#123;\n    if (compare(u)) tr[u].x &#x3D; tr[u &lt;&lt; 1].x;\n    else tr[u].x &#x3D; tr[u &lt;&lt; 1 | 1].x;\n&#125;\n\nvoid build(int u, int l, int r)&#123;\n    tr[u] &#x3D; &#123;l, r, w[r]&#125;;\n    if (l !&#x3D; r)&#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(u);\n    &#125;\n&#125;\n\nint query(int u, int l, int r)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].x;\n    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1, x &#x3D; 0;\n    if (l &lt;&#x3D; mid) x &#x3D; query(u &lt;&lt; 1, l, r);\n    if (r &gt; mid)&#123;\n        int y &#x3D; query(u &lt;&lt; 1 | 1, l, r);\n        if (num(l,r,x) &lt;&#x3D; num(l,r,y)) x &#x3D; y;\n    &#125;\n    return x;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n        scanf(&quot;%d&quot;, &amp;w[i]);\n        p[w[i]].push_back(i);\n    &#125;\n\n    build(1, 1, n);\n\n    int l, r;\n    while (q -- )&#123;\n        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);\n        int t &#x3D; query(1, l, r), len &#x3D; r - l + 1, mid &#x3D; (len + 1) &#x2F; 2, x &#x3D; num(l, r, t);\n        if (x &gt; mid)&#x2F;&#x2F;x超过区间长度一半，答案为2x-len\n            printf(&quot;%d\\n&quot;, 2 * x - len);\n        else puts(&quot;1&quot;);&#x2F;&#x2F;否则答案为1\n    &#125;\n&#125;\n\n莫队解法：还不会莫队，以后学了再填坑..\n","slug":"CF1514D.Cut and Stick","date":"2023-01-04T13:38:47.114Z","categories_index":"题记,Codeforces,Codeforces Round#716 (Div. 2),D2000,线段树,莫队","tags_index":"题记,codeforces,Codeforces Round#716 (Div. 2),D2000,线段树,莫队","author_index":"SMTTY"},{"id":"82c5266900e554d28363dfa4bc63c789","title":"洛谷P4145上帝造题的七分钟2/花神游历各国","content":"原题链接：LuoguP4145\n题目大意：首先第一行给出一个数字n，随后在下一行给出的n个整数作为初始数列，第三行给出一个m，代表有m个操作，在接下来的m行，每行包含三个整数k,l,r，其中k表示操作：\n\nk &#x3D; 0，表示给[l, r]区间内每个元素开平方(向下取整)。\nk &#x3D; 1，表示询问区间[l, r]内的元素和。数据范围：1 ≤ n, m ≤ 103，1 ≤ l, r ≤ n，数列中的数大于0，且不超过1012。注意：如果遇到l &gt; r的情况，需要交换l，r。\n\n线段树解法：维护区间和，并且支持修改和询问操作，很难不想到线段树；但此时出现一个问题，对于修改我们通常会使用懒标记，但因为操作是开方且向下取整，显然每个元素先开方再求和不等于它们的和开方，那么对于每一次操作必须下放到每一个元素，那么如果懒标记，那么只能统计开放次数，不难发现意义不大；从上面分析中，不难看出每次操作需要下放到每个元素，又m &lt;&#x3D; 105，且1012的数开方6次就变成1了，可知下放到每个元素是可行的；由数学知识，我们可以知道，当元素等于1的时候，无论如何开方，值仍为一，如果某一区间仅含有元素1，那么该区间执行操作前后值是一定不变的，此时就不用再向下递归去修改元素；对于判断区间是否全为1，可以维护区间长度，或者维护区间最大值，（我维护的是区间长度，就不提供维护区间最大值的代码了，仅需在上传pushup操作中加一个max左右儿子最大值即可）。\n线段树代码如下：#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nll w[N];\n\nstruct Node&#123;\n    int l, r;\n    ll sum, len;\n&#125; tr[N * 4];\n\nvoid pushup(int u)&#123;\n    tr[u].sum &#x3D; tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;\n&#125;\n\nvoid build(int u, int l, int r)&#123;\n    tr[u] &#x3D; &#123;l, r, w[r], r - l + 1&#125;;\n    if (l !&#x3D; r)&#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(u);\n    &#125;\n&#125;\n\nvoid modify(int u, int l, int r)&#123;\n    if (tr[u].len &#x3D;&#x3D; tr[u].sum) return;\n    &#x2F;&#x2F;如果区间元素均为1，则不需要继续向下递归\n\n    if (tr[u].l &#x3D;&#x3D; tr[u].r)&#123;\n        tr[u].sum &#x3D; sqrt(tr[u].sum);\n        return;\n    &#125;\n    &#x2F;&#x2F;如果已经修改到叶子节点，没有下一级继续去递归\n\n    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n    if (l &lt;&#x3D; mid)\n        modify(u &lt;&lt; 1, l, r);\n    if (r &gt; mid)\n        modify(u &lt;&lt; 1 | 1, l, r);\n    pushup(u);\n    &#x2F;&#x2F;记得上传计算sum\n&#125;\n\nll query(int u, int l, int r)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        return tr[u].sum;\n    else&#123;\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        ll res &#x3D; 0;\n        if (l &lt;&#x3D; mid)\n            res &#x3D; query(u &lt;&lt; 1, l, r);\n        if (r &gt; mid)\n            res +&#x3D; query(u &lt;&lt; 1 | 1, l, r);\n        return res;\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        scanf(&quot;%lld&quot;, &amp;w[i]);\n\n    build(1, 1, n);\n\n    scanf(&quot;%d&quot;, &amp;m);\n    int op, l, r;\n    while (m -- )&#123;\n        scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r);\n        if (l &gt; r) swap(l, r);\n        if (op &#x3D;&#x3D; 0) modify(1, l, r);\n        else printf(&quot;%lld\\n&quot;, query(1, l, r));\n    &#125;\n&#125;\n\n树状数组&amp;并查集解法：对数据范围进行分析，m &lt;&#x3D; 105，元素最大可以取到1012，而它仅需要开方6次就可以变成1，因此可以对每个元素修改；对于访问区间和，我们不难想到前缀和，而又需要修改操作，那么树状数组就可以满足我们的需要，对于每个元素，我们仅需要将修改后减去修改前得到的值，加到那个元素的位置即可；如果元素为1的话，那我们可以不进行修改操作，并且可以跳过所有元素为1的位置，此时，我们只需要将连续的1，以及其后一个位置放到一个连通块中，并且紧挨着这一串1，不为1的第一个数(或者结尾，即n+1位置)作为祖宗节点，这样，我们如果需要跳过一串1则可以通过将指针移到祖宗节点即可；那么对于，修改后为1的元素，我们将他的祖宗节点指向下一元素即可。\n树状数组&amp;并查集代码如下：#include&lt;iostream&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N &#x3D; 100010;\n\nll tr[N], a[N];\nint p[N], n, m;\n&#x2F;&#x2F;并查集\ninline int find(int x)&#123;\n    if (p[x] !&#x3D; x)\n        p[x] &#x3D; find(p[x]);\n    return p[x];\n&#125;\n&#x2F;&#x2F;返回x二进制中最后一个1的位置\ninline int lowbit(int x)&#123;\n    return x &amp; -x;\n&#125;\n&#x2F;&#x2F;树状数组修改操作\ninline void add(int x, ll c)&#123;\n    for (int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i))\n        tr[i] +&#x3D; c;\n&#125;\n&#x2F;&#x2F;树状数组求和\ninline ll sum(int x)&#123;\n    ll res &#x3D; 0;\n    for (int i &#x3D; x; i; i -&#x3D; lowbit(i))\n        res +&#x3D; tr[i];\n    return res;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n        scanf(&quot;%lld&quot;, &amp;a[i]);\n        add(i, a[i]);\n        p[i] &#x3D; i;\n    &#125;\n    scanf(&quot;%d&quot;, &amp;m);\n    p[n + 1] &#x3D; n + 1; \n    &#x2F;&#x2F;需要用到数列后面的一个点，因为他可能成为数列后缀的祖宗节点\n\n    int k, l, r;\n    ll t;\n    while(m -- ) &#123;\n        scanf(&quot;%d%d%d&quot;, &amp;k, &amp;l, &amp;r);\n        if (l &gt; r) swap(l, r);\n        if (k) printf(&quot;%lld\\n&quot;, sum(r) - sum(l - 1));\n        else\n            while(l &lt;&#x3D; r)&#123;\n                t &#x3D; (ll) sqrt(a[l]);\n                add(l, t - a[l]);&#x2F;&#x2F;修改树状数组\n                a[l] &#x3D; t;&#x2F;&#x2F;修改元素\n                if (t &#x3D;&#x3D; 1)\n                    p[l] &#x3D; l + 1, l &#x3D; find(l);\n                &#x2F;&#x2F;如果修改后值变为1，则需要将他合并到后一元素，并将指针移向其祖宗节点\n                else l++;\n                &#x2F;&#x2F;否则遍历下一元素\n            &#125;\n        &#125;\n\n&#125;","slug":"洛谷P4145上帝造题的七分钟2 花神游历各国","date":"2023-01-01T16:00:00.000Z","categories_index":"题记,洛谷,洛谷蓝题,线段树","tags_index":"题记,线段树,洛谷,洛谷蓝题","author_index":"SMTTY"},{"id":"16d11b6b9cafe480a32d8ef693f3287f","title":"CF1715B.Beautiful Array","content":"原题链接：CF1715B\n题目大意：定义长度为n的，仅包含非负数的《美丽的数组a》满足如下条件：1.Σai &#x3D; s；2.Σ[ai &#x2F; k] &#x3D; b(设[]为取整符号)。给出t组数据，每组数据给出n，k，b，s，如果可以构造出美丽的数组，输出一中满足条件的情况即可，如果无法构成，则输出-1。数据范围：1 ≤ t ≤ 1000，1 ≤ n ≤ 105，1 ≤ k ≤ 109，0 ≤ b ≤ 109，0 ≤ s ≤ 1018。\n分析思路：代码如下：#include&lt;iostream&gt;\nusing namespace std;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n;\n        long long k, b, s;\n        cin &gt;&gt; n &gt;&gt; k &gt;&gt; b &gt;&gt; s;\n        if (k * (b + 1) - 1 + (n - 1) * (k - 1) &lt; s)&#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        if (s &#x2F; k &lt; b)&#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        long long t &#x3D; min(k * (b + 1) - 1, s);\n        cout &lt;&lt; t &lt;&lt; &#39; &#39;;\n        s -&#x3D; t;\n        for (int i &#x3D; 1; i &lt; n; i ++ )&#123;\n            t &#x3D; min(k - 1, s);\n            cout &lt;&lt; t &lt;&lt; &#39; &#39;;\n            s -&#x3D; t;\n        &#125;\n        puts(&quot;&quot;);\n    &#125;\n&#125;","slug":"CF1715B.Beautiful Array","date":"2022-11-14T06:40:22.319Z","categories_index":"题记,Codeforces,Codeforces Round#816 (Div. 2),D1000,贪心","tags_index":"题记,codeforces,Codeforces Round#816 (Div. 2),D1000,贪心","author_index":"SMTTY"},{"id":"be568de8bdceebc7a1f08f027f734efa","title":"CF1748B.Diverse Substrings","content":"原题链接：CF1748B\n题目大意：在t组数据中，每一组给出一个长度为n的字符串，字符串所有可能包含的数字为[0, 9]。定义多样化的一个概念，即如果字符串中一个数字的出现次数小于等于该字符串出现的不同数字的数量，那么这个字符串是多样化的。例如：1.”7”具有多样性，其中7出现的次数为1小于等于不同数字的数量1；2.”77”不具有多样性，因为7出现的次数2大于不同数字的数量1；3.”1010”具有多样性，因为0和1都出现了2次且都小于不同数字的数量2。再比如”668”、”996”、”121”等都具有多样性，而”6668”、”1211”等是不具有多样性的。问给出的字符串的子串中(自身也算作自己的子串)有多少字符串具有多样性，且下标不同的子串不算同一子串，如”77”中第一个”7”和第二个”7”算作两个子串。数据范围：1 ≤ t ≤ 104，1 ≤ n ≤ 105，Σn ≤ 105。\n分析思路：我能想到的是暴力比对：定义满足条件子串数量为cnt，每个下标开始向右遍历，记录数字的最大出现次数，以及出现的不同数字数量，用一个数组分别记录0到9出现的次数，并且每一次更改更新一次最大值，再用一个变量去记录不同数字的数量，考虑到”996”这种情况，并不能单纯的在最大出现次数大于不同数字数量之后直接break，那我们要选取一个计数方式，即当且仅当最大出现次数小于等于不同数字数量时cnt++；此时又注意到数据范围，每次遍历到n的话，显然会超时，那通过分析我们知道当0到9均出现的时候，取得不同数字数量的最大值10，那也就是说如果最大出现次数大于10的时候，一定不存在满足条件的子串，此时break，从而使每次循环次数最多不超过100，显然不会超时了。\n代码如下：#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nint s[10];\nstring c;\n\nvoid solve()&#123;\n    int n, t, cnt &#x3D; 0, x &#x3D; 0, m;\n    cin &gt;&gt; n &gt;&gt; c;\n    for (int i &#x3D; 0; i &lt; n; i ++ )&#123;\n        memset(s, 0, sizeof s);\n        x &#x3D; 0, m &#x3D; 0;\n        for (int j &#x3D; i; j &lt; n; j ++ )&#123;\n            t &#x3D; c[j] - &#39;0&#39;;\n            if (!s[t])\n                x++;\n            s[t]++;\n            m &#x3D; max(s[t], m);\n            if (m &gt; 10)\n                break;\n            if (m &lt;&#x3D; x)\n                cnt++;\n        &#125;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt; endl;\n&#125;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )\n        solve();\n&#125;","slug":"CF1748B.Diverse Substrings","date":"2022-11-14T05:58:26.190Z","categories_index":"题记,Codeforces,Codeforces Round#833 (Div. 2),D1400,暴力","tags_index":"题记,codeforces,暴力,Codeforces Round#833 (Div. 2),D1400","author_index":"SMTTY"},{"id":"68b928afb15542d56e18953acc9e7637","title":"CF1598B.Groups","content":"原题链接：CF1598B\n题目大意：在每组测试数据中，给出n个人(n为偶数)，然后在n行中每行由5个或0或1的数字组成，用来描述这个人周一到周五哪一天方便上课，有课为1，没课为0。问：能否将这n个人均分为两组，每一组都能在同一天上课，且两组上课不在同一天。数据范围：1 ≤ t ≤ 104，2 ≤ n ≤ 1000，Σt*n ≤ 105。\n分析思路：分析题意和数据范围，这道题显然是个暴力比对的题；对于可供选择的两天，方便的同学都应不小于n &#x2F; 2，然后比对有多少同学是两天都方便，有多少是一天方便，如果两天都方便的可以把另外两天只有一天方便的人数补到n &#x2F; 2，那么就可以平均分配；如果任何两天都不可以那就不能。\n代码如下：#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N &#x3D; 1010;\n\nint n;\nint a[N][5], sum[5];\n&#x2F;&#x2F;判断能否分配到这两天\nbool judge(int l, int r)&#123;\n    int x &#x3D; 0, y &#x3D; 0, z &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n        if (a[i][l] &amp;&amp; a[i][r])\n            z++;\n        else if (a[i][l])\n            x++;\n        else if (a[i][r])\n            y++;\n    int t &#x3D; n &#x2F; 2;\n    int k &#x3D; max(0, t - x) + max(0, t - y);\n    if (z &gt;&#x3D; k)\n        return true;\n    return false;\n&#125;\n\nvoid solve()&#123;\n    cin &gt;&gt; n;\n    memset(a, 0, sizeof a);\n    memset(sum, 0, sizeof sum);\n    &#x2F;&#x2F;读入，并预处理每天方便的同学有多少\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n        for (int j &#x3D; 0; j &lt; 5; j ++ )&#123;\n            cin &gt;&gt; a[i][j];\n            if (a[i][j])\n                sum[j]++;\n        &#125;\n\n    for (int i &#x3D; 0; i &lt; 4; i ++ )\n        for (int j &#x3D; i + 1; j &lt; 5; j ++ )\n            if (sum[i] &gt;&#x3D; n &#x2F; 2 &amp;&amp; sum[j] &gt;&#x3D; n &#x2F; 2)\n                if (judge(i, j))&#123;\n                    puts(&quot;YES&quot;);\n                    return;\n                &#125;\n    puts(&quot;NO&quot;);\n&#125;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )\n        solve();\n&#125;","slug":"CF1598B.Groups","date":"2022-11-10T16:00:00.000Z","categories_index":"题记,Codeforces,Educational Codeforces Round 115 (Rated for Div. 2),D1000,暴力","tags_index":"题记,codeforces,D1000,Educational Codeforces Round 115 (Rated for Div. 2),暴力","author_index":"SMTTY"},{"id":"93f431eb174c74436b204f9604320531","title":"Trie树","content":"一种以树状结构储存字符串的方法。\n板子如下：int son[N][26], cnt[N], idx;\n&#x2F;&#x2F; 0号点既是根节点，又是空节点\n&#x2F;&#x2F; son[][]存储树中每个节点的子节点\n&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量\n\n&#x2F;&#x2F; 插入一个字符串\nvoid insert(char str[])\n&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )\n    &#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u]) son[p][u] &#x3D; ++ idx;\n        p &#x3D; son[p][u];\n    &#125;\n    cnt[p] ++ ;\n&#125;\n\n&#x2F;&#x2F; 查询字符串出现的次数\nint query(char str[])&#123;\n    int p &#x3D; 0;\n    for (int i &#x3D; 0; str[i]; i ++ )&#123;\n        int u &#x3D; str[i] - &#39;a&#39;;\n        if (!son[p][u])\n            return 0;\n        p &#x3D; son[p][u];\n    &#125;\n\n    return cnt[p];\n&#125;","slug":"Trie树","date":"2022-11-09T16:00:00.000Z","categories_index":"算法模板,数据结构,Trie树","tags_index":"算法模板,数据结构,Trie树","author_index":"SMTTY"},{"id":"b6f2c460c174967b06c32707c0b7231a","title":"CF1722D.Line","content":"原题链接：CF1722D\n题目大意：有n个人站在一条水平线上，每个人要么向左看，要么向右看，每个人都数着他们所看向的方向上能看到多少人，他们看到的人数之和记为每个人的计数之和；比方说，队列LRRLL中，L表示该位置的人向左看，R表示向右看，那么这个队列每个人的计数为[0, 3, 2, 3, 4]，每个人的计数之和为12.现在我们知道一个队列的初步安排，对于从1到n每次递增1的k，每次最多改变k个人的方向；确保每次改变k个人方向后。计数之和尽可能大，并输出每次的最大值，用空格间隔开。共给出t组数据，每组数据第一行给出一个n表示队列人数，下一行有一个由LR组成的长度为n的字符串，表示队列的初步安排。数据范围：1 ≤ t ≤ 100，1 ≤ n ≤ 2* 105，Σn ≤ 2*105，对于答案需要64bit容器，如C++的long long。\n分析思路：观察发现，如果改变一个人的朝向，会使计数之和产生一个变化，可能为正，也可能为负；又因为队伍的长度我们是提前知道的，也就是说在知道第i个人朝向时，我们可以计算出如果令这个人转头对计数之和的影响，当然我们只记录增加的影响，因为需要输出最大值，为了简化后续循环，如果转头会使计数之和减少，那么我们不会让这个人转头，记录为0即可；然后对这些记录进行排序，之后进行一次从大到小遍历，使当前计数之和加上影响，然后输出。\n代码如下：#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\n\nvoid quick_sort(vector&lt;int&gt; &amp;q, int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n\n    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[(l + r) &#x2F; 2];\n    while (i &lt; j)\n    &#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    &#125;\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n&#125;\n\n\nint main()&#123;\n    int t;\n    cin &gt;&gt; t;\n    for (int tt &#x3D; 0; tt &lt; t; tt ++ )&#123;\n        int n;\n        long long x &#x3D; 0;\n        char c;\n        cin &gt;&gt; n;\n        vector&lt;int&gt; p;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n            cin &gt;&gt; c;\n            if(c &#x3D;&#x3D; &#39;R&#39;)&#123;\n                p.push_back(max(i - 1 - (n - i), 0));\n                x +&#x3D; n - i;\n            &#125;\n            else&#123;\n                p.push_back(max(n - i - (i - 1), 0));\n                x +&#x3D; i - 1;\n            &#125;\n        &#125;\n        quick_sort(p, 0, n - 1);\n        for (int i &#x3D; p.size() - 1; i &gt;&#x3D; 0; i -- )&#123;\n            x +&#x3D; p[i];\n            cout &lt;&lt; x &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n        p.clear();\n    &#125;\n&#125;","slug":"CF1722D.Line","date":"2022-11-08T16:00:00.000Z","categories_index":"题记,Codeforces,Codeforces Round#827 (Div. 4),D1100,贪心","tags_index":"题记,codeforces,贪心,Codeforces Round#827 (Div. 4),D1100","author_index":"SMTTY"},{"id":"4cbd9d4467c43b05e611447308ee64f8","title":"CF1742E.Scuza","content":"原题链接：CF1742E\n题目大意：有这么一段楼梯，总共有n级台阶，设地面高度是0，每段楼梯距离前一级楼梯(或者地面)有一定高度ai，总共有q个问题，每个问题给出一个人所能跨上的最高距离，我们需要计算出这个人最高能上升的高度。共给出t组数据，每组数据第一行给出n，q表示台阶数和问题个数，第二行有n个数字，表示每级台阶高度，第三行有q个数字，表示每个问题中所能跨上的最大高度；对于输出，每组数据的答案用空格隔开，每组数据输出一行。数据范围：1 ≤ t ≤ 100，1 ≤ n,q ≤ 2105，1 ≤ ai ≤ 109，0 ≤ ki ≤ 109，Σn ≤ 2105，Σq ≤ 2* 105。\n分析思路：分析可知，这段楼梯各级高度并不一定是单调递增的，也就是说可能在一级较高的楼梯后面可能存在很多较低的楼梯，也就是说我们可以预处理出来一串数字，代表这个人最小跨上高度和这个高度对应的上升高度；那么怎么构造这个数组呢，可以在读入的时候记录当前读入的每级台阶的最大高度，如果读入的高度小于最大高度，那么当前坐标最大上升高度加上这级台阶高度，否则，替换最大高度，坐标++，最大上升高度等于上一坐标最大上升高度加上这一级台阶高度。预处理如上，接下来对于每一个问题，我们可以采用二分查找确定答案，C++中upper_bound的内部实现就是二分查找，直接使用即可。为了防止这个人最大跨上高度大于最大台阶高度而使答案错误，我在预处理数组后端添加了一个无限大。\n代码如下：#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 200010;\n\nlong long a[N], b[N], idx;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n, q, x, t;\n        cin &gt;&gt; n &gt;&gt; q;\n        idx &#x3D; 0;\n        a[0] &#x3D; 0, b[0] &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i ++ )&#123;\n            cin &gt;&gt; x;\n            if (x &gt; a[idx])&#123;\n                idx++;\n                a[idx] &#x3D; x;\n                b[idx] &#x3D; x + b[idx - 1];\n            &#125;\n            else\n                b[idx] +&#x3D; x;\n        &#125;\n        a[idx + 1] &#x3D; 0x3f3f3f3f;\n        while (q--) &#123;\n            cin &gt;&gt; x;\n            t &#x3D; upper_bound(a, a + idx + 1, x) - a;\n            cout &lt;&lt; b[t - 1] &lt;&lt; &#39; &#39;;\n            &#125;\n        puts(&quot;&quot;);\n    &#125;\n&#125;","slug":"CF1742E.Scuza","date":"2022-11-08T16:00:00.000Z","categories_index":"题记,Codeforces,Codeforces Round#827 (Div. 4),D1200,贪心,二分查找","tags_index":"题记,codeforces,贪心,Codeforces Round#827 (Div. 4),D1200,二分查找","author_index":"SMTTY"},{"id":"e185d61ae3cd4ae90fd39cfd13028509","title":"CF1743C.Save the Magazines","content":"原题链接：CF1743C\n题目大意：有个人收集了很多有价值的报纸，分别放在了从编号1到n的n个箱子中，有个箱子有盖子，而有的箱子没有，记第i个箱子中的报纸数为ai;突然！就很突然，下雨了，有盖子的箱子中的报纸不会被淋湿，而没盖子的箱子中报纸会被淋湿，这个人想去拯救尽可能多的报纸，所以他需要去移动盖子，而盖子有一定的移动规律：每个盖子最多只能向左移动一位，即当n ≥ i ≥ 2时，第i个盖子如果移动，只能被移动到第编号i-1的箱子上。问：这个人最多能使多少报纸不被淋湿。数据说明：共有t组数据，每组数据第一行给出n代表箱子个数，接下来第一行有n个数字，代表第i个箱子中的报纸数，下一行是01序列，0表示该位置没有盖子，1表示有盖子。数据范围：1 ≤ t ≤ 104，1 ≤ n ≤ 2* 105，1 ≤ ai ≤ 104，Σn ≤ 2*105。\n分析思路：观察01序列，分析盖子移动方式我们可以将序列类型分为三种：1.最前面可能出现一串1，此时盖子是无法也不用去移动的，这些报纸都可以不被淋湿；2.对于一串0，在最后一个0之前的所有报纸都一定会被淋湿，因为一个盖子最多只能向左移动一次，那么最后一个0以前没有盖子的箱子，无论如何移动都不能获得盖子；3.对于0然后多个1的情况，我们可以通过移动使得序列变为一个0和多个1所组成的任何序列，以0111为例，我们可以移动为1011,1101,1110,也可以不移动，即总有一个箱子的报纸会被淋湿。接下来就是对这些情况的处理了，对于第一种情况，只能出现在开头，所以可以预处理，也可以在循环里面进行判断；第二种情况，我们对序列扫描时，如果当前位置和下一位置全是0，则可以跳过考虑当前位置的报纸，因为一定会被淋湿；对于第三种情况，我们需要截取一个0和其之后挨着的所有1，我们可以通过从第一个0一直截取到下一个0，然后考虑第一个0到下一个0之前的1的区间内，一定会有一个箱子的报纸会被淋湿，所以我们希望是最小数量的报纸，这时我们所能挽救的报纸数等于01..1的报纸数之和减去这段中报纸数的最小值；同时考虑到序列最后可能是01111..1，则我们需要在序列最末加上一个0以便扫描。\n代码如下：#include&lt;iostream&gt;\nusing namespace std;\n\nconst int N &#x3D; 200010;\n\nint a[N], b[N];\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n, sum &#x3D; 0;\n        cin &gt;&gt; n;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            scanf(&quot;%1d&quot;, &amp;a[i]);\n        a[n] &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i ++ )\n            cin &gt;&gt; b[i];\n        b[n] &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            if (a[i] &#x3D;&#x3D; 0 &amp;&amp; a[i + 1] &#x3D;&#x3D; 0)\n                continue;\n            if (a[i] &#x3D;&#x3D; 1) &#123;\n                while (a[i]) &#123;\n                    sum +&#x3D; b[i];\n                    i++;\n                &#125;\n                i--;\n            &#125;\n            int m &#x3D; b[i];\n            sum +&#x3D; b[i];\n            while (a[i + 1])&#123;\n                m &#x3D; min(m, b[i + 1]);\n                sum +&#x3D; b[i + 1];\n                i++;\n            &#125;\n            sum -&#x3D; m;\n        &#125;\n        cout &lt;&lt; sum &lt;&lt; endl;\n    &#125;\n&#125;","slug":"CF1743C.Save the Magazines","date":"2022-11-08T16:00:00.000Z","categories_index":"题记,Codeforces,Educational Codeforces Round 137 (Rated for Div. 2),D1100,贪心","tags_index":"题记,codeforces,贪心,D1100,Educational Codeforces Round 137 (Rated for Div. 2)","author_index":"SMTTY"},{"id":"235723fad9e0f351ec569d7c8ca68497","title":"CF1716B.Permutation Chain","content":"原题链接：CF1716B\n题目大意：定义第i个数刚好是i的点为不动点，一个排列的不动性是其中不动点的数量；给出t组数据；在每组数据中，给出一个n，我们需要构造尽可能多的序列，使其不动性依次严格递减。每组数据输出最多的序列数k，然后接下来k行输出这些排列(答案有很多种，满足题意即可)。数据范围：1 ≤ t ≤ 99，2 ≤ n ≤ 100。\n分析思路：太难翻了，直接说人话就是构造n个序列，使不动点数依次减少即可，而我们分析可知，第一次输出一定是原排列，第二次一定是交换会使不动性减少2，因为移动原排列的数字最少会破坏它本身和另一个数字的不动性，之后每次最少可以使不动性减少1，所以共输出n个排列；接下来考虑这么逐次破坏排列，可以循环交换i与第i+1个数，最后再把第一个数和最后一个数交换，共输出n行即可，也可以利用递归逐渐打乱。\n代码如下：循环打乱：\n#include&lt;iostream&gt;\nusing namespace std;\n \nint a[110];\n \nvoid out(int x)&#123;\n    for (int i &#x3D; 1; i &lt;&#x3D; x; i ++ )\n        cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n    puts(&quot;&quot;);\n&#125;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n;\n        cin &gt;&gt; n;\n        cout &lt;&lt; n &lt;&lt; endl;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            a[i] &#x3D; i;\n        int t &#x3D; n - 2, i &#x3D; 1;\n        out(n);\n        while (t --)&#123;\n            swap(a[i], a[i + 1]);\n            out(n);\n            i++;\n        &#125;\n        swap(a[1], a[n]);\n        out(n);\n    &#125;\n&#125;\n\n递归打乱：\n#include&lt;iostream&gt;\nusing namespace std;\n\nint a[110], n;\n\nvoid solve(int i,int j)&#123;\n\tswap(a[i], a[j]);\n    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )\n        cout &lt;&lt; a[k] &lt;&lt; &#39; &#39;;\n    puts(&quot;&quot;);\n    int k &#x3D; (j + i) &#x2F; 2;\n    if (k + 1 &lt; j)\n        solve(k + 1, j);\n    if (k &gt; i)\n        solve(i, k);\n&#125;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while(_ -- ) &#123;\n        cin &gt;&gt; n;\n        cout &lt;&lt; n &lt;&lt; endl;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n            a[i] &#x3D; i;\n            cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n        &#125;\n        puts(&quot;&quot;);\n        solve(1, n);\n        &#125;\n&#125;","slug":"CF1716B.Permutation Chain","date":"2022-11-07T16:00:00.000Z","categories_index":"题记,Codeforces,Educational Codeforces Round 133 (Rated for Div. 2),D800,数学","tags_index":"题记,codeforces,Educational Codeforces Round 133 (Rated for Div. 2),D800,数学","author_index":"SMTTY"},{"id":"5329850074d4a4358b32a48b44c0c487","title":"CF1744C.Traffic Light","content":"原题链接：CF1744C\n题目大意：有那么有一个有大病的交通信号灯，它会按一个规律一直循环闪烁(依然还是RYG三色，且还是只有绿灯可以通行)，这个规律用一个字符串描述，如rggry，那么它的闪烁就是rggryrggry…循环往复，可以知道现在的红绿灯时什么颜色，但是不知道现在的时间，需要找出保证过马路的最短时间。总共有t组数据，每组数据给出一个n表示红绿灯的最小循环的长度，然后一个字符c表示现在红绿灯的颜色，下一行给出长度为n的字符串，描述红绿灯的循环。数据范围：1 ≤ t ≤ 104，1 ≤ n ≤ 2*105，c∈{r, y, g}。\n分析思路：题面非常具有迷惑性，虽然是最短时间，但是要的是保证过马路的最短时间，也就是最短时间限制的是看到g就过马路，而保证过马路的最短时间就是在c之后看到g的最大时间间隔；如果是c &#x3D; ‘g’，那么可以直接过，输出0即可，而如果c是r或者y，我们则需要搜寻在其右侧出现的第一个g的距离，最后比较求出最大值(因为是循环闪烁，所以我们可以使S延长一倍，从而达到模拟循环的效果)。为了避免超时，我们需要做出一些优化：当c ≠ ‘g’时，c与其右端第一个g之间的c都可以跳过判断，因为其长度一定小于当前判断的长度。\n代码如下：#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n, ans &#x3D; 0, j;\n        char c;\n        string s;\n        cin &gt;&gt; n &gt;&gt; c &gt;&gt; s;\n        if (c &#x3D;&#x3D; &#39;g&#39;)&#123;\n            puts(&quot;0&quot;);\n            continue;\n        &#125;\n        s +&#x3D; s;\n        for (int i &#x3D; 0; i &lt; n; i ++ )&#123;\n            if (c &#x3D;&#x3D; s[i])&#123;\n                for (j &#x3D; i + 1;; j ++ )\n                    if (s[j] &#x3D;&#x3D; &#39;g&#39;)\n                        break;\n            &#125;\n            else\n                continue;\n            ans &#x3D; max(ans, j - i);\n            i &#x3D; j;&#x2F;&#x2F;省略中间部分出现的c\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; endl;\n    &#125;\n&#125;","slug":"CF1744C.Traffic Light","date":"2022-11-07T16:00:00.000Z","categories_index":"题记,Codeforces,Codeforces Round#828 (Div. 3),D1000,双指针","tags_index":"题记,codeforces,D1000,Codeforces Round#828 (Div. 3),双指针","author_index":"SMTTY"},{"id":"f43c88fb6011bc7c9f20123aabe01edd","title":"CF1744D.Divisibility by 2^n","content":"原题链接:CF1744D\n题目大意：共有t组数据，每组数据给出一个n，然后在下一行中给出n个数字a1,a2,…,an。可以执行一种操作：取i∈[1, n]，使得ai&#x3D;aii，对于每个i最多只能执行一次操作。问：操作多少次可以使得Π(pai，求积符号)ai能被2n整除，若无论如何操作都无法整除则输出-1，否则输出操作次数。数据范围：1 ≤ t ≤ 104，1 ≤ n ≤ 2105，1 ≤ ai ≤ 109；Σn ≤ 2*105。\n分析思路：我们知道，任何一个大于1的自然数可以分解为有限个质数的积；而2是质数，那么能被2n整除，则其可以被分解出至少n个因数2。那么我们统计初始时ai中因数2的个数cnt，然后再记录i中因数2的个数，然后对其存储并排序。如果初始时cnt &gt;&#x3D; n，那么不需要任何操作，输出0；反之，则从大到小遍历每个i中因数2的个数，cnt累加因数2的个数，如果在某次相加后cnt &gt;&#x3D; n，输出操作个数；如果遍历完，仍cnt &lt; n，那么输出-1。\n代码如下：#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n \nvector&lt;int&gt; a;\n&#x2F;&#x2F;返还x中因数2的个数 \nint num(int x)&#123;\n    int res &#x3D; 0;\n    while (x % 2 &#x3D;&#x3D; 0)&#123;\n        x &#x2F;&#x3D; 2;\n        res++;\n    &#125;\n    return res;\n&#125;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        a.clear();\n        int n, cnt &#x3D; 0, x, ans &#x3D; 0;\n        cin &gt;&gt; n;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n            cin &gt;&gt; x;\n            cnt +&#x3D; num(x);\n            if (i % 2 &#x3D;&#x3D; 0)\n                a.push_back(num(i));\n        &#125;\n        if (cnt &gt;&#x3D; n)&#123;\n            puts(&quot;0&quot;);\n            continue;\n        &#125;\n        sort(a.begin(), a.end());\n        for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i -- )&#123;\n            ans++;\n            cnt +&#x3D; a[i];\n            if (cnt &gt;&#x3D; n)\n                break;\n        &#125;\n        if (cnt &gt;&#x3D; n)\n            cout &lt;&lt; ans &lt;&lt; endl;\n        else\n            puts(&quot;-1&quot;);\n    &#125;\n&#125;","slug":"CF1744D.Divisibility by 2^n","date":"2022-11-07T16:00:00.000Z","categories_index":"题记,Codeforces,Codeforces Round#828 (Div. 3),D1200,贪心","tags_index":"题记,codeforces,贪心,D1200,Codeforces Round#828 (Div. 3)","author_index":"SMTTY"},{"id":"ec81d70b1346c4b4569d5c4b5f32b11d","title":"CF1749B.Death's Blessing","content":"原题链接：CF1749B\n题目大意：游戏中，有一排怪物，他们都有一定的血量，分别为a1,a2,…,an，同时，每个怪物都有一个死亡祝福bi，当某一怪物被杀死后，他身旁的怪物的生命会受到死亡祝福增加(怪物站成一排，第一个和最后一个怪物不相邻)，并且当一个怪物被杀死后，整排会缩小，使得他之前的邻居变得相邻，即若这一排有三个怪物，击杀第二个怪物之后，第一第三个怪物会变得相邻；假设我们每造成一点伤害需要一秒时间，我们需要求出杀死这一排怪物最少需要多少时间。总共给出t组测试数据，每组数据中给出怪物数量n，接下来第一行a1,a2,…,an表示每只怪物的血量，下一行b1,b2,…,bi表示每只怪物的血量。数据范围：1 ≤ t ≤ 104，1 ≤ n ≤ 2* 105，1 ≤ ai ≤ 109，0 ≤ bi ≤ 109，Σn ≤ 2*105。\n分析思路：因为我们需要将这一排怪物全部击杀，所以所有的ai是我们无法避免的；再观察bi的叠加规律，首先发现，最后一只击杀的怪物的b是不需要考虑的，即不用累加，而其他怪物都会向两侧传递bi，但是在两侧的怪只能向一侧传递，并且击败他们之后，他们的邻居会重新成为排头，分析可知最佳方案应该是从两边开始打怪，并且bi最大的怪最后打；那么所需要的时间最小值就被确定为Σai + Σbi - max(bi)。\n代码如下：#include&lt;iostream&gt;\nusing namespace std;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n, m &#x3D; 0, x;\n        long long ans &#x3D; 0;\n        cin &gt;&gt; n;\n        for (int i &#x3D; 0; i &lt; n; i ++ )&#123;\n            cin &gt;&gt; x;\n            ans +&#x3D; x;\n        &#125;\n        for (int i &#x3D; 0; i &lt; n; i ++ )&#123;\n            cin &gt;&gt; x;\n            m &#x3D; max(m, x);\n            ans +&#x3D; x;\n        &#125;\n        ans -&#x3D; m;\n        cout &lt;&lt; ans &lt;&lt; endl;\n    &#125;\n&#125;","slug":"CF1749B.Death's Blessing","date":"2022-11-06T16:00:00.000Z","categories_index":"题记,Codeforces,Educational Codeforces Round 138 (Rated for Div. 2),D900,贪心","tags_index":"题记,codeforces,贪心,Educational Codeforces Round 138 (Rated for Div. 2),D900","author_index":"SMTTY"},{"id":"e2877b7fa24b8c65939a980db8467f26","title":"区间合并","content":"非常好理解的板子，用的也非常少，就是把区间合并。\n板子如下：&#x2F;&#x2F; 将所有存在交集的区间合并\ntypedef pair&lt;int, int&gt; PII;\n\nvoid merge(vector&lt;PII&gt; &amp;segs)\n&#123;\n    vector&lt;PII&gt; res;\n\n    sort(segs.begin(), segs.end());\n\n    int st &#x3D; -2e9, ed &#x3D; -2e9;\n    for (auto seg : segs)\n        if (ed &lt; seg.first)\n        &#123;\n            if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n            st &#x3D; seg.first, ed &#x3D; seg.second;\n        &#125;\n        else ed &#x3D; max(ed, seg.second);\n\n    &#x2F;&#x2F;上面遍历无法对最后一个区间进行插入操作，故需要再次判断插入一遍\n    if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);\n\n    segs &#x3D; res;\n&#125;","slug":"区间合并","date":"2022-11-06T16:00:00.000Z","categories_index":"算法模板,区间合并","tags_index":"算法模板,区间合并","author_index":"SMTTY"},{"id":"5996424ecd7fa41d224f56f7fc47f943","title":"差分","content":"差分用于大量的数组中部分数据的加减操作，不必再遍历部分区间进行加减，而是通过对部分位置的操作即可完成对区间所有元素的加减，最后再累加即可得到每个元素的值。\n一维差分板子：&#x2F;&#x2F;给区间[l, r]中的每个数加上c：\nB[l] +&#x3D; c, B[r + 1] -&#x3D; c\n&#x2F;&#x2F;初始化相当于在[i, i]插入一个值 \n\n二维差分板子：&#x2F;&#x2F;a[i][j]是第i行j列格子左上部分所有元素的和\n&#x2F;&#x2F;给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c\n&#x2F;&#x2F;初始化相当于在x1&#x3D;i,x2&#x3D;i,y1&#x3D;j,y2&#x3D;j处插入一个值","slug":"差分","date":"2022-11-06T16:00:00.000Z","categories_index":"算法模板,差分","tags_index":"差分,算法模板","author_index":"SMTTY"},{"id":"79d3d24c6264cf3d036dbffe252e1981","title":"栈","content":"栈：&#x2F;&#x2F; tt表示栈顶\nint stk[N], tt &#x3D; 0;\n\n&#x2F;&#x2F; 向栈顶插入一个数\nstk[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从栈顶弹出一个数\ntt -- ;\n\n&#x2F;&#x2F; 栈顶的值\nstk[tt];\n\n&#x2F;&#x2F; 判断栈是否为空\nif (tt &gt; 0)\n&#123;\n\n&#125;","slug":"栈","date":"2022-11-06T16:00:00.000Z","categories_index":"算法模板,数据结构,栈","tags_index":"算法模板,数据结构,栈","author_index":"SMTTY"},{"id":"911a72b9cf1301cce1d0e6e3bd36166b","title":"洛谷P1955[NOI2015]程序自动分析","content":"原题链接：LuoguP1955\n用到的知识：并查集、离散化\n题目大意：总共有t个问题数；每次问题都是独立的，且每个问题都有若干条件，在每个问题中给出一个正整数n，代表条件的关系数，接下来的n行中每行有三个数i, j, e表示约束条件，当e为1时表示条件i &#x3D; 条件j，当e为0时表示条件i ≠ 条件j，问这些约束条件是否能够同时满足，若能输出YES，不能输出NO。数据范围：1 ≤ t ≤ 10，1 ≤ n ≤ 106，1 ≤ i,j ≤ 109，e∈{0, 1}。\n分析思路：首先分析问题，如果两个条件相等可以看作在两个点之间连了一条无向边，即条件1&#x3D;条件2，条件2&#x3D;条件3，则可以推导出条件1&#x3D;条件3，可以发现连边可以表示为将两个集合合并，如果不等那么两个条件不处于同一集合，问题可用并查集解决；其次观察数据i,j的范围大小远大于2*n，为了并查集的初始化不超时，我们需要用到离散化去缩小数据范围，并且不需要保序，可以用哈希表进行无序离散化，直接用unordered_map解决离散化，且如果存在相悖条件，一定出现在不相等处，那么就可以先将相等关系合并，然后检查不相等关系是否成立，不成立则所有约束条件不能同时满足，反之可以同时满足。\n代码如下：#include&lt;iostream&gt;\n#include&lt;unordered_map&gt;\nusing namespace std;\n\nconst int N &#x3D; 2000010;\n\nunordered_map&lt;int, int&gt; s;\n\nint n, m, q;\nint x[N], y[N], p[N];\n\n&#x2F;&#x2F;离散化加点及查询\nint get(int z)&#123;\n    if (s.count(z) &#x3D;&#x3D; 0)\n        s[z] &#x3D; ++n;\n    return s[z];\n&#125;\n\n&#x2F;&#x2F;并查集\nint find(int z)&#123;\n    if (p[z] !&#x3D; z)\n        p[z] &#x3D; find(p[z]);\n    return p[z];\n&#125;\n\nint main()&#123;\n    int _;\n    scanf(&quot;%d&quot;, &amp;_);\n    while (_ --)&#123;\n        n &#x3D; q &#x3D; 0;\n        s.clear();\n        cin &gt;&gt; m;\n        for (int i &#x3D; 1; i &lt;&#x3D; 2 * m; i ++ )\n            p[i] &#x3D; i;\n\n        for (int i &#x3D; 0; i &lt; m; i ++ )&#123;\n            int a, b, c;\n            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n            &#x2F;&#x2F;相等条件先处理，记录不等关系\n            if (c)&#123;\n                a &#x3D; get(a), b &#x3D; get(b);\n                p[find(a)] &#x3D; find(b);\n            &#125;\n            else&#123;\n                x[q] &#x3D; get(a);\n                y[q] &#x3D; get(b);\n                q++;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;检查不等关系是否满足\n        bool f &#x3D; true;\n        for (int i &#x3D; 0; i &lt; q; i ++ )\n            if (find(x[i]) &#x3D;&#x3D; find(y[i]))&#123;\n                f &#x3D; false;\n                break;\n            &#125;\n        \n        if (f)\n            puts(&quot;YES&quot;);\n        else\n            puts(&quot;NO&quot;);\n    &#125;\n&#125;","slug":"洛谷P1955[NOI2015]程序自动分析","date":"2022-11-06T16:00:00.000Z","categories_index":"题记,洛谷,洛谷绿题,并查集,离散化","tags_index":"题记,洛谷,洛谷绿题,并查集,离散化","author_index":"SMTTY"},{"id":"7f00768b865696d227f7b794a43f7717","title":"离散化","content":"对于一个非常大的数据范围内，需要使用的值远远小于数据范围的时候，需要用离散化去优化，即将所有需要用到的值映射到一个小的数据范围中。其中有的题的离散化需要保序，即若x&lt;y，则离散化后x’&lt;y’也要成立；而有的题则不需要保序，可以用哈希表去进行映射操作，花费时间更少。\n保序离散化板子：vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值\nsort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素\n\n&#x2F;&#x2F; 二分求出x对应的离散化的值\nint find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n\n&#125;\n\n若环境不支持unique函数则需要手写：\n&#x2F;&#x2F;vector需先排序\nvector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a)&#123;\n    int j &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; a.size(); i ++ )\n        if (!i || a[i] !&#x3D; a[i - 1])\n            a[j ++ ] &#x3D; a[i];\n    &#x2F;&#x2F; a[0] ~ a[j - 1]所有a中不重复的数\n\n    return a.begin() + j;\n&#125;\n\n无序离散化板子：&#x2F;&#x2F;unordered_map的内部实现是哈希表，直接调用\n&#x2F;&#x2F;插入+调用一个函数解决\nint get(int z)&#123;\n    if (s.count(z) &#x3D;&#x3D; 0)\n        s[z] &#x3D; ++n;\n    return s[z];\n&#125;\n\n手写的哈希表链接：哈希表\n","slug":"离散化","date":"2022-11-06T16:00:00.000Z","categories_index":"算法模板,离散化","tags_index":"算法模板,离散化","author_index":"SMTTY"},{"id":"b48ae5252cdf21a431ed1030afed6c71","title":"洛谷P1002[NOIP2002 普及组]过河卒","content":"原题链接：LuoguP1002\n题目分析：就是如果可以走到点(i，j)，那么方案数f(i, j) &#x3D; f(i - 1, j) + f(i, j - 1)。数据范围：1 ≤ n, m ≤ 20，0 ≤ 马的坐标 ≤ 20。\n代码如下：#include&lt;iostream&gt;\nusing namespace std;\n\nint cx[8] &#x3D; &#123;1, 1, 2, 2, -1, -1, -2, -2&#125;;\nint cy[8] &#x3D; &#123;2, -2, 1, -1, 2, -2, 1, -1&#125;;\n\nint main()&#123;\n    int n, m, x, y;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;\n    long long f[25][25] &#x3D; &#123;&#125;;\n    int p[25][25] &#x3D; &#123;&#125;;\n    f[2][2] &#x3D; 1;\n    p[2][2]++;\n    n +&#x3D; 2;\n    m +&#x3D; 2;\n    x +&#x3D; 2;\n    y +&#x3D; 2;\n    p[x][y]++;\n    for (int i &#x3D; 0; i &lt; 8; i++)\n        p[x + cx[i]][y + cy[i]]++;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i++)\n        for (int j &#x3D; 2; j &lt;&#x3D; m; j++)\n            if (p[i][j] &#x3D;&#x3D; 0)\n                f[i][j] &#x3D; f[i - 1][j] + f[i][j - 1];\n    cout &lt;&lt; f[n][m];\n&#125;","slug":"洛谷P1002[NOIP2002 普及组]过河卒","date":"2022-11-06T16:00:00.000Z","categories_index":"题记,洛谷,洛谷橙题,dp","tags_index":"题记,洛谷,洛谷橙题,dp","author_index":"SMTTY"},{"id":"0d5be13038d02acb3bbf4a07263c6953","title":"链表","content":"单链表：&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    head &#x3D; -1;\n    idx &#x3D; 0;\n&#125;\n\n&#x2F;&#x2F; 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head &#x3D; ne[head];\n&#125;\n\n双链表：&#x2F;&#x2F; e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    &#x2F;&#x2F;0是左端点，1是右端点\n    r[0] &#x3D; 1, l[1] &#x3D; 0;\n    idx &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] &#x3D; x;\n    l[idx] &#x3D; a, r[idx] &#x3D; r[a];\n    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] &#x3D; l[a];\n    r[l[a]] &#x3D; r[a];\n&#125;","slug":"链表","date":"2022-11-06T16:00:00.000Z","categories_index":"算法模板,数据结构,链表","tags_index":"算法模板,数据结构,链表","author_index":"SMTTY"},{"id":"1840725987698b4cef5a9ce40df0584c","title":"队列","content":"普通队列：&#x2F;&#x2F; hh 表示队头，tt表示队尾\nint q[N], hh &#x3D; 0, tt &#x3D; -1;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[ ++ tt] &#x3D; x;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh &lt;&#x3D; tt)\n&#123;\n\n&#125;\n\n循环队列：&#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh &#x3D; 0, tt &#x3D; 0;\n\n&#x2F;&#x2F; 向队尾插入一个数\nq[tt ++ ] &#x3D; x;\nif (tt &#x3D;&#x3D; N) tt &#x3D; 0;\n\n&#x2F;&#x2F; 从队头弹出一个数\nhh ++ ;\nif (hh &#x3D;&#x3D; N) hh &#x3D; 0;\n\n&#x2F;&#x2F; 队头的值\nq[hh];\n\n&#x2F;&#x2F; 判断队列是否为空\nif (hh !&#x3D; tt)\n&#123;\n\n&#125;","slug":"队列","date":"2022-11-06T16:00:00.000Z","categories_index":"算法模板,数据结构,队列","tags_index":"算法模板,数据结构,队列","author_index":"SMTTY"},{"id":"e88334e7a5c70ad04602dfc5e3fc14b6","title":"CF1746A.Maxmina","content":"原题链接：CF1746A\n题目大意：总共有t组数字，每组数据给出一个序列长度n和一个数字k，接下来会有n个数（记作a1, a2,…, an）且仅为0或1。可以执行以下两种操作：1.选择一个数字i∈[1, n - 1]，使得ai &#x3D; ai+1 &#x3D; min(ai, ai+1)，每执行一次，序列长度n减少1。2.选择一个数字i∈[1, n - k + 1]，使得ai到ai+k-1这k个数等于这个区间的最大值，每执行一次，序列长度n减少k - 1。问：执行若干操作后能否使n &#x3D; 1的同时a1 &#x3D; 1，若能输出YES，不能就输出NO。数据范围：1 ≤ t ≤ 1000，2 ≤ k ≤ n ≤ 50。\n分析思路：仔细分析两个操作，发现两个操作都可以针对到序列中的全部元素，即从1到n的元素都可以被操作到，因为序列元素非0即1，如果序列中存在1，那么操作2可以把序列中所有元素替换为1，若长度n仍不为1，操作1、2都可以在不对1更改的情况下使n减至1；如果序列中不存在1，那么任何操作都不能制造一个1出来，则不能满足题意。此时问题就简化到给出序列是否含有1。\n代码如下：#include&lt;iostream&gt;\nusing namespace std;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n, k;\n        bool f &#x3D; false;\n        cin &gt;&gt; n &gt;&gt; k;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n            cin &gt;&gt; k;\n            if(k)\n                f &#x3D; true;\n        &#125;\n        if (f)\n            puts(&quot;YES&quot;);\n        else\n            puts(&quot;NO&quot;);\n    &#125;\n&#125;","slug":"CF1746A.Maxmina","date":"2022-11-04T16:00:00.000Z","categories_index":"题记,Codeforces,Codeforces Global Round 23,D800,贪心","tags_index":"题记,codeforces,D800,贪心,Codeforces Global Round 23","author_index":"SMTTY"},{"id":"944cbc217b8e8a1f5e95edb3117a8bea","title":"CF1754A.Technical Support","content":"原题链接：CF1754A\n题目大意：总共有t组数据，每组数据给出一个n，随后给出n个字符，且字符仅为Q或者A。问：所有的Q能否在其后面找到A配对，每个Q、A只能配对一次，能就输出Yes，不能就输出No。数据范围：1 ≤ t ≤ 500，1 ≤ n ≤ 100。\n分析思路：就是判断每个Q之后有没有A能配对，且每个A只能和一个Q配对。我们可以先定义一个记录还未配对的Q的个数的变量cnt，每读到Q，cnt+1，读到A，cnt-1，但是注意一处特判：如果cnt为零，且当前读入字符为A，则不必执行cnt-1，因为仅需要保证每个Q都有A配对，不需要每个A都有Q去配对，因此cnt&#x3D;0时，读入A，直接跳过。\n代码如下：#include&lt;iostream&gt;\nusing namespace std;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n, cnt &#x3D; 0;\n        char c;\n        cin &gt;&gt; n;\n        for (int i &#x3D; 0; i &lt; n; i ++ )&#123;\n            cin &gt;&gt; c;\n            if (c &#x3D;&#x3D; &#39;A&#39; &amp;&amp; cnt &#x3D;&#x3D; 0)\n                continue;\n            if (c &#x3D;&#x3D; &#39;Q&#39;)\n                cnt++;\n            else\n                cnt--;\n        &#125;\n        if (cnt &#x3D;&#x3D; 0)\n            puts(&quot;Yes&quot;);\n        else\n            puts(&quot;No&quot;);\n    &#125;\n&#125;","slug":"CF1754A.Technical Support","date":"2022-11-04T16:00:00.000Z","categories_index":"题记,Codeforces,Codeforces Round#829 (Div.2),D800,贪心","tags_index":"题记,codeforces,D800,贪心,Codeforces Round#829 (Div.2)","author_index":"SMTTY"},{"id":"7c8267ca3bcbb0a1983078a7d4c8df82","title":"CF1754B.Kevin and Permutation","content":"原题链接：CF1754B\n题目大意：总共有t组数据，每组数据给出一个n，输出一个从1到n的排列，使得min(|pi+1-pi|)最大。即：找出使任意两个数的差值的最小值最大的一个排列，如果有多种答案，输出一种即可。数据范围：1 ≤ t ≤ 100，2 ≤ n ≤ 1000。\n分析思路：先看题给数据：n&#x3D;4时，排列可以为2 4 1 3，使得相邻最小的差值为所有可能的排列中的最大值；n&#x3D;3时，排位可以为1 2 3，同样也可以满足题意。不难发现，理论上最小差值的最大值应该是n &#x2F; 2，构造成n &#x2F; 2 + 1, 1, n &#x2F; 2 + 2, 2 …这种形式一定满足题意，因为这种方式使得两数之差要么是n &#x2F; 2，要么是n &#x2F; 2 + 1，使得最小差值取得最大值，那么把代码敲出来就解决问题了。\n代码如下：#include&lt;iostream&gt;\nusing namespace std;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n, f &#x3D; true;\n        cin &gt;&gt; n;\n        for (int i &#x3D; n &#x2F; 2 + 1, j &#x3D; 1; i &lt;&#x3D; n || j &lt;&#x3D; n &#x2F; 2;)&#123;\n            if (f)&#123;\n                cout &lt;&lt; i++ &lt;&lt; &quot; &quot;;\n                f &#x3D; false;\n            &#125;\n            else&#123;\n                cout &lt;&lt; j++ &lt;&lt; &quot; &quot;;\n                f &#x3D; true;\n            &#125;\n        &#125;\n        puts(&quot;&quot;);\n    &#125;\n&#125;\n","slug":"CF1754B.Kevin and Permutation","date":"2022-11-04T16:00:00.000Z","categories_index":"题记,Codeforces,Codeforces Round#829 (Div.2),D800,贪心","tags_index":"题记,codeforces,D800,贪心,Codeforces Round#829 (Div.2)","author_index":"SMTTY"},{"id":"241d076c874b2badab1c87882a2d2fef","title":"洛谷P3853[TJOI2007]路标设置","content":"原题链接：LuoguP3853\n用到的知识：整数二分\n题目大意：在一段长 L 的公路上某些地方设有 N 个路标（保证起点终点开始时都有路标），它们的位置是与起点的距离表示，但是有人还是嫌少，所以又要添加 K 个路标，路标可以添加到任意位置。涉及的所有数据全部都为整数，2 ≤ N ≤ 105，0 ≤ K ≤ 105，0 ≤ L ≤ 107。已知：公路上相邻路标的最大距离定义为公路的空旷指数。求：相邻路标求添加路标后的最小空旷指数的值。\n做题历程：错误思路：最开始我的想法是求出开始时全部相邻的路灯的距离，存入大根堆，然后循环K次，每次取出堆顶t，将其分为t &#x2F; 2，(t + 1) &#x2F; 2两部分后再次插入大根堆，最后的堆顶就是答案。然后就是很自信的提交，就是很自信的WA。\n分析错因：再次分析不难发现如果某次最大距离是50，而剩余的操作次数是3次，按照上述思路，则被分为25，13，12；而不难发现分为17，17，16才是此时的最佳方案。也就是说一步一步的贪心是不够找到最小的最大值的。\n正确思路：再次分析，一种解决方案是（我也只能想到这种了）可以通过二分查找在[0, L]中搜索答案，而搜寻条件就是能否在K次内将每个间隔控制在mid内，如果可以则更新left坐标，否则更新right坐标，直到找到临界点，即为答案。\n代码如下：#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n, l, k;\nint a[N]; &#x2F;&#x2F; a[N]用来储存相邻路灯的距离\n\nbool check(int x)&#123;\n    int cnt &#x3D; 0;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n        if (a[i] - a[i - 1] &gt;&#x3D; x)&#123;\n            cnt +&#x3D; (a[i] - a[i - 1]) &#x2F; x; \n            &#x2F;&#x2F; 统计如果分割至最大距离为x需要操作次数\n            if ((a[i] - a[i - 1]) % x &#x3D;&#x3D; 0) cnt--;  \n            &#x2F;&#x2F;如果刚好整除，即刚好整分，需要刨除一次多余的操作\n        &#125;\n    if (cnt &gt; k) return false;\n    return true;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; l &gt;&gt; n &gt;&gt; k;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        cin &gt;&gt; a[i];\n    \n    int le &#x3D; 1, ri &#x3D; l + 1;\n    while (le &lt; ri)&#123;\n        if (check((le + ri) &#x2F; 2)) ri &#x3D; (le + ri) &#x2F; 2;\n        else le &#x3D; (le + ri) &#x2F; 2 + 1;\n    &#125;\n    cout &lt;&lt; le &lt;&lt; endl; &#x2F;&#x2F; 此处le &#x3D; ri 输出哪个都一样\n&#125;\n\n新增hack点注意：2022十月份到十一月份左右新增了一组hack数据，如果出现RE，可能是二分时左边界取0时，可能导致mid &#x3D; 0，从而除数为0。\n","slug":"洛谷P3853[TJOI2007]路标设置","date":"2022-11-03T16:00:00.000Z","categories_index":"题记,洛谷,洛谷绿题,二分答案","tags_index":"题记,二分答案,洛谷,洛谷绿题","author_index":"SMTTY"},{"id":"7e125c2fcf5388ca1ef0a457d9c6ee91","title":"前缀和","content":"前缀和可以将区间和优化成O(1)，即对于区间内的值之和，变成一个公式的计算，如一位前缀和对于[a,b]区间求和转化为S[b] - S[a - 1].\n一维前缀和板子：S[i] &#x3D; a[1] + a[2] + ... a[i] &#x2F;&#x2F;预处理\na[l] + ... + a[r] &#x3D; S[r] - S[l - 1] &#x2F;&#x2F;调用\n\n二维前缀和板子：&#x2F;&#x2F;S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和\n&#x2F;&#x2F;以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n\nS[ i , j ] &#x3D; S[ i - 1 , j ] + S[ i , j - 1] - S[ i - 1 , j - 1] + a[ i , j ]","slug":"前缀和","date":"2022-11-02T16:00:00.000Z","categories_index":"算法模板,前缀和","tags_index":"算法模板,前缀和","author_index":"SMTTY"},{"id":"d516ffba6431f809e15e274d7a5146cc","title":"高精度乘法","content":"一般只用到一个高精度乘一个小数。\n板子如下：&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n&#123;\n    vector&lt;int&gt; C;\n\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )\n    &#123;\n        if (i &lt; A.size()) t +&#x3D; A[i] * b;\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n\n    return C;\n&#125;","slug":"高精度乘法","date":"2022-11-02T16:00:00.000Z","categories_index":"算法模板,高精度模板,高精度乘法","tags_index":"算法模板,高精度模板,高精度乘法","author_index":"SMTTY"},{"id":"82f48f9fee67ca6334cb02910bc05e80","title":"高精度除法","content":"主要还是用整除得商和余，得一定位数小数目前没有见到做题用到，就先跳过了。\n板子如下：&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int&gt; C;\n    r &#x3D; 0;\n    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )\n    &#123;\n        r &#x3D; r * 10 + A[i];\n        C.push_back(r &#x2F; b);\n        r %&#x3D; b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;","slug":"高精度除法","date":"2022-11-02T16:00:00.000Z","categories_index":"算法模板,高精度模板,高精度除法","tags_index":"算法模板,高精度模板,高精度除法","author_index":"SMTTY"},{"id":"feb3f716faa59646e6cdce3816112649","title":"高精度加法","content":"当计算的数据大于最大的容器，则需要手写高精度加法。\n板子如下：&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t +&#x3D; A[i];\n        if (i &lt; B.size()) t +&#x3D; B[i];\n        C.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n\n    if (t) C.push_back(t);\n    return C;\n&#125;\n\n算法思路：就是加法的原理：1.大整数存储时个位存在0位2.原位置对10取模，商数进位\n","slug":"高精度加法","date":"2022-11-02T16:00:00.000Z","categories_index":"算法模板,高精度模板,高精度加法","tags_index":"算法模板,高精度模板,高精度加法","author_index":"SMTTY"},{"id":"17d279e898f5a808206279d482f69cd8","title":"高精度减法","content":"板子如下：&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )\n    &#123;\n        t &#x3D; A[i] - t;\n        if (i &lt; B.size()) t -&#x3D; B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t &#x3D; 1;\n        else t &#x3D; 0;\n    &#125;\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();\n    return C;\n&#125;","slug":"高精度减法","date":"2022-11-02T16:00:00.000Z","categories_index":"算法模板,高精度模板,高精度减法","tags_index":"算法模板,高精度模板,高精度减法","author_index":"SMTTY"},{"id":"5689f65fc84adf6e03dbdcbe8815a58b","title":"堆排序","content":"重点在于模拟堆的up和down操作，但是在C++中优先队列priority_queue默认是大根堆，这个板子所以写的也会非常少。\n板子如下：void down(int u)&#123;\n    int t &#x3D; u;\n    if (u * 2 &lt;&#x3D; siz &amp;&amp; h[u * 2] &lt; h[t])\n        t &#x3D; u * 2;\n    if (u * 2 + 1 &lt;&#x3D; siz &amp;&amp; h[u * 2 + 1] &lt; h[t])\n        t &#x3D; u * 2 + 1;\n    if (u !&#x3D; t)&#123;\n        swap(h[u], h[t]);\n        down(t);\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        scanf(&quot;%d&quot;, &amp;h[i]);\n    siz &#x3D; n;\n\n    for (int i &#x3D; n &#x2F; 2; i; i -- )\n        down(i);\n\n    while (m -- )&#123;\n        printf(&quot;%d &quot;, h[1]);\n        h[1] &#x3D; h[siz];\n        siz--;\n        down(1);\n    &#125;\n&#125;\n补充:模拟堆须知：&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置\n&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n\n堆的up操作:void up(int u)\n&#123;\n    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])\n    &#123;\n        heap_swap(u, u &#x2F; 2);\n        u &gt;&gt;&#x3D; 1;\n    &#125;\n&#125;\n\n建堆：&#x2F;&#x2F; O(n)建堆\nfor (int i &#x3D; n &#x2F; 2; i; i -- ) down(i);\n\n交换两个点，及其映射关系：void heap_swap(int a, int b)\n&#123;\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n&#125;\n\n模拟堆可支持的功能：模拟堆的功能：1.插入一个数：heap[ ++ size ] &#x3D; x; up( size );2.求集合中的最小值：heap[ 1 ];3.删除最小值：heap[ 1 ] &#x3D; heap[ size ]; size–; down( 1 );4.删除任意一个元素：heap[ k ] &#x3D; heap[ size ]; size –; down( k ); up( k );5.修改任意一个元素：heap[ k ] &#x3D; x; down( k ); up( k );\n","slug":"堆排序","date":"2022-11-01T16:00:00.000Z","categories_index":"算法模板,排序模板,堆排序","tags_index":"算法模板,排序模板,堆排序","author_index":"SMTTY"},{"id":"f463b7e04b9afca016a6c3b848f9e77c","title":"整数二分","content":"对于贪心，某些题会出现WA，比方说逐步贪心的时候每次取出最大值除二，会使最小值偏大如洛谷P3853，则需要用二分去搜索答案。\n板子如下：bool check(int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质\n        else l &#x3D; mid + 1;\n    &#125;\n    return l;\n&#125;\n&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l &#x3D; mid;\n        else r &#x3D; mid - 1;\n    &#125;\n    return l;\n&#125;\n\n以下是我的听课笔记，由Acwing yxc讲解：分析二分：二分的本质并不是单调性，有单调性固然可以二分，无单调性时也有可能二分；其本质在于，给定一个区间，在这个区间上定义了某种性质，该性质在右半边满足，在左半边不满足，如果可以找到这样的性质，可以使这个区间一分为二，一半满足一半不满足，则二分可以寻找这个性质的边界。\n两种情况下的二分：1.通过左边性质查找时mid &#x3D; (l + r + 1) &#x2F; 2     if( check( mid ) ) 检查中间值，如果为真（满足条件）则mid一定在左区间，答案位于[ mid , r ]，然后将l更新为mid；如果为假（不满足条件）则mid一定在右区间，答案位于[ l , mid - 1 ]，然后将r更新为mid - 12.通过右边性质查找时mid &#x3D; (l + r) &#x2F; 2    if( check( mid ) ) true→mid位于[ l , mid ] r更新为mid ; false→mid位于[ mid + 1 , r ] l更新为mid + 1\n","slug":"整数二分","date":"2022-11-01T16:00:00.000Z","categories_index":"算法模板,二分模板,整数二分","tags_index":"算法模板,二分模板,整数二分","author_index":"SMTTY"},{"id":"c668d79bcd807cc57a11ce29c7e08a39","title":"归并排序","content":"归并排序的速度一般都小于sort函数，一般用的很少，但该学还得学啊。\n板子如下：void merge_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int mid &#x3D; l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)\n        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];\n        else tmp[k ++ ] &#x3D; q[j ++ ];\n\n    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];\n    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];\n\n    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];\n&#125;\n\n以下是我的听课笔记，由Acwing yxc讲解：算法思路：1.确定分界点  mid &#x3D; ( l + r ) &#x2F; 22.递归排序左边和右边3.归并——合二为一\n","slug":"归并排序","date":"2022-11-01T16:00:00.000Z","categories_index":"算法模板,排序模板,归并排序","tags_index":"算法模板,排序模板,归并排序","author_index":"SMTTY"},{"id":"9c04d15496da1d73edddda137155e866","title":"快速排序","content":"虽然C++中sort的耗时与快排几乎一样，但是快排仍然需要我们去了解，板子也是要记住的，以便应对不能用sort排序，或是sort会耗时更大的情况。\n板子如下：void quick_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;&#x3D; r) return;\n\n    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];\n    while (i &lt; j)\n    &#123;\n        do i ++ ; while (q[i] &lt; x);\n        do j -- ; while (q[j] &gt; x);\n        if (i &lt; j) swap(q[i], q[j]);\n    &#125;\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n&#125;\n注意事项：递归时若将j换为i,则应改为quick_sort(q, l, i - 1), quick_sort(q, i, r)；       且x一定不可取q[ l ]，可取q[ r ]或者q[( l + r + 1) &#x2F; 2]（l+r+1为了向上取整），若取到l，则会死循环；同理用j时，x不可取q[ r ]，不然会产生死循环。\n以下是我的听课笔记，由Acwing yxc讲解：初步分析：1.确定分界点 q[ l ]  q[ (l+r) &#x2F; 2]  q[ r ]2.调整区间 左区间&lt;&#x3D;x  右区间&gt;&#x3D;x3.递归处理左右两段\n暴力做法：1.开两个额外数组a[ ]  b[ ]2.扫描q[l ~ r]中&lt;&#x3D;x插入a[ ]中，&gt;x插入b[ ]中3.先将a[ ]中数字放入q[ ]，再将b[ ]中数字放入q[ ]\n优雅做法：1.l ~ r 区间，i指针l→r，j指针l←r2.当i（或j）位置元素&gt;（或&lt;&#x3D;）x时，i（或j）指针停止移动3.当i，j指针均停止移动时交换i，j位置元素4.交换之后i，j指针再次移动，直到相遇（或穿过）（此时不交换元素），此时i指针左侧元素全部&lt;&#x3D;x，j指针右侧元素全部&gt;x\n","slug":"快速排序","date":"2022-11-01T16:00:00.000Z","categories_index":"算法模板,排序模板,快速排序","tags_index":"算法模板,排序模板,快速排序","author_index":"SMTTY"},{"id":"95868cb257f78c07f576c8cba24d1e61","title":"浮点二分","content":"就是二分逼近答案，比方说二分法求零点。\n板子如下：bool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n&#123;\n    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    &#123;\n        double mid &#x3D; (l + r) &#x2F; 2;\n        if (check(mid)) r &#x3D; mid;\n        else l &#x3D; mid;\n    &#125;\n    return l;\n&#125;","slug":"浮点二分","date":"2022-11-01T16:00:00.000Z","categories_index":"算法模板,二分模板,浮点二分","tags_index":"算法模板,二分模板,浮点二分","author_index":"SMTTY"}]