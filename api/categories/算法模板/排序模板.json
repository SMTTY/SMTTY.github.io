{"name":"排序模板","slug":"算法模板/排序模板","count":3,"postlist":[{"title":"堆排序","uid":"5689f65fc84adf6e03dbdcbe8815a58b","slug":"堆排序","date":"2022-11-01T16:00:00.000Z","updated":"2022-11-01T16:00:00.000Z","comments":true,"path":"api/articles/堆排序.json","keywords":"notes","cover":null,"text":"重点在于模拟堆的up和down操作，但是在C++中优先队列priority_queue默认是大根堆，这个板子所以写的也会非常少。 板子如下：void down(int u)&#123; int t &#x3D; u; if (u * 2 &lt;&#x3D; siz &amp;&...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"排序模板","slug":"算法模板/排序模板","count":3,"path":"api/categories/算法模板/排序模板.json"},{"name":"堆排序","slug":"算法模板/排序模板/堆排序","count":1,"path":"api/categories/算法模板/排序模板/堆排序.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"排序模板","slug":"排序模板","count":3,"path":"api/tags/排序模板.json"},{"name":"堆排序","slug":"堆排序","count":1,"path":"api/tags/堆排序.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"归并排序","uid":"c668d79bcd807cc57a11ce29c7e08a39","slug":"归并排序","date":"2022-11-01T16:00:00.000Z","updated":"2022-11-01T16:00:00.000Z","comments":true,"path":"api/articles/归并排序.json","keywords":"notes","cover":null,"text":"归并排序的速度一般都小于sort函数，一般用的很少，但该学还得学啊。 板子如下：void merge_sort(int q[], int l, int r) &#123; if (l &gt;&#x3D; r) return; int mid &#x3D; l + r &gt;&...","link":"","photos":[],"count_time":{"symbolsCount":716,"symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"排序模板","slug":"算法模板/排序模板","count":3,"path":"api/categories/算法模板/排序模板.json"},{"name":"归并排序","slug":"算法模板/排序模板/归并排序","count":1,"path":"api/categories/算法模板/排序模板/归并排序.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"排序模板","slug":"排序模板","count":3,"path":"api/tags/排序模板.json"},{"name":"归并排序","slug":"归并排序","count":1,"path":"api/tags/归并排序.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"快速排序","uid":"9c04d15496da1d73edddda137155e866","slug":"快速排序","date":"2022-11-01T16:00:00.000Z","updated":"2022-11-01T16:00:00.000Z","comments":true,"path":"api/articles/快速排序.json","keywords":"notes","cover":null,"text":"虽然C++中sort的耗时与快排几乎一样，但是快排仍然需要我们去了解，板子也是要记住的，以便应对不能用sort排序，或是sort会耗时更大的情况。 板子如下：void quick_sort(int q[], int l, int r) &#123; if (l &gt;&#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"排序模板","slug":"算法模板/排序模板","count":3,"path":"api/categories/算法模板/排序模板.json"},{"name":"快速排序","slug":"算法模板/排序模板/快速排序","count":1,"path":"api/categories/算法模板/排序模板/快速排序.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"排序模板","slug":"排序模板","count":3,"path":"api/tags/排序模板.json"},{"name":"快速排序","slug":"快速排序","count":1,"path":"api/tags/快速排序.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}