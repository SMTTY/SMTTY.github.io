{"title":"CF1716B.Permutation Chain","uid":"235723fad9e0f351ec569d7c8ca68497","slug":"CF1716B.Permutation Chain","date":"2022-11-07T16:00:00.000Z","updated":"2022-11-07T16:00:00.000Z","comments":true,"path":"api/articles/CF1716B.Permutation Chain.json","keywords":"notes","cover":null,"content":"<p>原题链接<a href=\"https://codeforces.com/contest/1716/problem/B\">CF1716B</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>定义第i个数刚好是i的点为不动点，一个排列的不动性是其中不动点的数量；给出t组数据；在每组数据中，给出一个n，我们需要构造尽可能多的序列，使其不动性依次严格递减。<br>每组数据输出最多的序列数k，然后接下来k行输出这些排列(答案有很多种，满足题意即可)。<br>数据范围：1 &lt;&#x3D; t &lt;&#x3D; 99，2 &lt;&#x3D; n &lt;&#x3D; 100。</p>\n<h3 id=\"分析思路：\"><a href=\"#分析思路：\" class=\"headerlink\" title=\"分析思路：\"></a>分析思路：</h3><p>太难翻了，直接说人话就是构造n个序列，使不动点数依次减少即可，而我们分析可知，第一次输出一定是原排列，第二次一定是交换会使不动性减少2，因为移动原排列的数字最少会破坏它本身和另一个数字的不动性，之后每次最少可以使不动性减少1，所以共输出n个排列；接下来考虑这么逐次破坏排列，可以循环交换i与第i+1个数，最后再把第一个数和最后一个数交换，共输出n行即可，也可以利用递归逐渐打乱。</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><p>循环打乱：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n \nint a[110];\n \nvoid out(int x)&#123;\n    for (int i &#x3D; 1; i &lt;&#x3D; x; i ++ )\n        cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n    puts(&quot;&quot;);\n&#125;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n;\n        cin &gt;&gt; n;\n        cout &lt;&lt; n &lt;&lt; endl;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            a[i] &#x3D; i;\n        int t &#x3D; n - 2, i &#x3D; 1;\n        out(n);\n        while (t --)&#123;\n            swap(a[i], a[i + 1]);\n            out(n);\n            i++;\n        &#125;\n        swap(a[1], a[n]);\n        out(n);\n    &#125;\n&#125;</code></pre>\n\n<p>递归打乱：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nint a[110], n;\n\nvoid solve(int i,int j)&#123;\n\tswap(a[i], a[j]);\n    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )\n        cout &lt;&lt; a[k] &lt;&lt; &#39; &#39;;\n    puts(&quot;&quot;);\n    int k &#x3D; (j + i) &#x2F; 2;\n    if (k + 1 &lt; j)\n        solve(k + 1, j);\n    if (k &gt; i)\n        solve(i, k);\n&#125;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while(_ -- ) &#123;\n        cin &gt;&gt; n;\n        cout &lt;&lt; n &lt;&lt; endl;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n            a[i] &#x3D; i;\n            cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n        &#125;\n        puts(&quot;&quot;);\n        solve(1, n);\n        &#125;\n&#125;</code></pre>","feature":false,"text":"原题链接CF1716B 题目大意：定义第i个数刚好是i的点为不动点，一个排列的不动性是其中不动点的数量；给出t组数据；在每组数据中，给出一个n，我们需要构造尽可能多的序列，使其不动性依次严格递减。每组数据输出最多的序列数k，然后接下来k行输出这些排列(答案有很多种，满足题意即可)...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":16,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":13,"path":"api/categories/题记/Codeforces.json"},{"name":"Educational Codeforces Round 133 (Rated for Div. 2)","slug":"题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2.json"},{"name":"D800","slug":"题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2/D800","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2/D800.json"},{"name":"数学","slug":"题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2/D800/数学","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2/D800/数学.json"}],"tags":[{"name":"题记","slug":"题记","count":16,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":13,"path":"api/tags/codeforces.json"},{"name":"Educational Codeforces Round 133 (Rated for Div. 2)","slug":"Educational-Codeforces-Round-133-Rated-for-Div-2","count":1,"path":"api/tags/Educational-Codeforces-Round-133-Rated-for-Div-2.json"},{"name":"D800","slug":"D800","count":4,"path":"api/tags/D800.json"},{"name":"数学","slug":"数学","count":1,"path":"api/tags/数学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">分析思路：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CF1722D.Line","uid":"b6f2c460c174967b06c32707c0b7231a","slug":"CF1722D.Line","date":"2022-11-08T16:00:00.000Z","updated":"2022-11-08T16:00:00.000Z","comments":true,"path":"api/articles/CF1722D.Line.json","keywords":"notes","cover":null,"text":"原题链接CF1722D 题目大意：有n个人站在一条水平线上，每个人要么向左看，要么向右看，每个人都数着他们所看向的方向上能看到多少人，他们看到的人数之和记为每个人的计数之和；比方说，队列LRRLL中，L表示该位置的人向左看，R表示向右看，那么这个队列每个人的计数为[0, 3, 2...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":16,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":13,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#827 (Div. 4)","slug":"题记/Codeforces/Codeforces-Round-827-Div-4","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-827-Div-4.json"},{"name":"D1100","slug":"题记/Codeforces/Codeforces-Round-827-Div-4/D1100","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-827-Div-4/D1100.json"},{"name":"贪心","slug":"题记/Codeforces/Codeforces-Round-827-Div-4/D1100/贪心","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-827-Div-4/D1100/贪心.json"}],"tags":[{"name":"题记","slug":"题记","count":16,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":13,"path":"api/tags/codeforces.json"},{"name":"贪心","slug":"贪心","count":9,"path":"api/tags/贪心.json"},{"name":"Codeforces Round#827 (Div. 4)","slug":"Codeforces-Round-827-Div-4","count":2,"path":"api/tags/Codeforces-Round-827-Div-4.json"},{"name":"D1100","slug":"D1100","count":2,"path":"api/tags/D1100.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"CF1744C.Traffic Light","uid":"5329850074d4a4358b32a48b44c0c487","slug":"CF1744C.Traffic Light","date":"2022-11-07T16:00:00.000Z","updated":"2022-11-07T16:00:00.000Z","comments":true,"path":"api/articles/CF1744C.Traffic Light.json","keywords":"notes","cover":null,"text":"原题链接CF1744C 题目大意：有那么有一个有大病的交通信号灯，它会按一个规律一直循环闪烁(依然还是RYG三色，且还是只有绿灯可以通行)，这个规律用一个字符串描述，如rggry，那么它的闪烁就是rggryrggry…循环往复，可以知道现在的红绿灯时什么颜色，但是不知道现在的时间...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"题记","slug":"题记","count":16,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":13,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#828 (Div. 3)","slug":"题记/Codeforces/Codeforces-Round-828-Div-3","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3.json"},{"name":"D1000","slug":"题记/Codeforces/Codeforces-Round-828-Div-3/D1000","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3/D1000.json"},{"name":"双指针","slug":"题记/Codeforces/Codeforces-Round-828-Div-3/D1000/双指针","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3/D1000/双指针.json"}],"tags":[{"name":"题记","slug":"题记","count":16,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":13,"path":"api/tags/codeforces.json"},{"name":"D1000","slug":"D1000","count":3,"path":"api/tags/D1000.json"},{"name":"Codeforces Round#828 (Div. 3)","slug":"Codeforces-Round-828-Div-3","count":2,"path":"api/tags/Codeforces-Round-828-Div-3.json"},{"name":"双指针","slug":"双指针","count":1,"path":"api/tags/双指针.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}