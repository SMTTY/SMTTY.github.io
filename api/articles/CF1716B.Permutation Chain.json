{"title":"CF1716B.Permutation Chain","uid":"235723fad9e0f351ec569d7c8ca68497","slug":"CF1716B.Permutation Chain","date":"2022-11-07T16:00:00.000Z","updated":"2022-11-07T16:00:00.000Z","comments":true,"path":"api/articles/CF1716B.Permutation Chain.json","keywords":"notes","cover":"/images/cf.png","content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://codeforces.com/contest/1716/problem/B\">CF1716B</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>定义第i个数刚好是i的点为不动点，一个排列的不动性是其中不动点的数量；给出t组数据；在每组数据中，给出一个n，我们需要构造尽可能多的序列，使其不动性依次严格递减。<br>每组数据输出最多的序列数k，然后接下来k行输出这些排列(答案有很多种，满足题意即可)。<br>数据范围：1 ≤ t ≤ 99，2 ≤ n ≤ 100。</p>\n<h3 id=\"分析思路：\"><a href=\"#分析思路：\" class=\"headerlink\" title=\"分析思路：\"></a>分析思路：</h3><p>太难翻了，直接说人话就是构造n个序列，使不动点数依次减少即可，而我们分析可知，第一次输出一定是原排列，第二次一定是交换会使不动性减少2，因为移动原排列的数字最少会破坏它本身和另一个数字的不动性，之后每次最少可以使不动性减少1，所以共输出n个排列；接下来考虑这么逐次破坏排列，可以循环交换i与第i+1个数，最后再把第一个数和最后一个数交换，共输出n行即可，也可以利用递归逐渐打乱。</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><p>循环打乱：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n \nint a[110];\n \nvoid out(int x)&#123;\n    for (int i &#x3D; 1; i &lt;&#x3D; x; i ++ )\n        cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n    puts(&quot;&quot;);\n&#125;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n;\n        cin &gt;&gt; n;\n        cout &lt;&lt; n &lt;&lt; endl;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n            a[i] &#x3D; i;\n        int t &#x3D; n - 2, i &#x3D; 1;\n        out(n);\n        while (t --)&#123;\n            swap(a[i], a[i + 1]);\n            out(n);\n            i++;\n        &#125;\n        swap(a[1], a[n]);\n        out(n);\n    &#125;\n&#125;</code></pre>\n\n<p>递归打乱：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nint a[110], n;\n\nvoid solve(int i,int j)&#123;\n\tswap(a[i], a[j]);\n    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )\n        cout &lt;&lt; a[k] &lt;&lt; &#39; &#39;;\n    puts(&quot;&quot;);\n    int k &#x3D; (j + i) &#x2F; 2;\n    if (k + 1 &lt; j)\n        solve(k + 1, j);\n    if (k &gt; i)\n        solve(i, k);\n&#125;\n \nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while(_ -- ) &#123;\n        cin &gt;&gt; n;\n        cout &lt;&lt; n &lt;&lt; endl;\n        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n            a[i] &#x3D; i;\n            cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n        &#125;\n        puts(&quot;&quot;);\n        solve(1, n);\n        &#125;\n&#125;</code></pre>","feature":false,"text":"原题链接：CF1716B 题目大意：定义第i个数刚好是i的点为不动点，一个排列的不动性是其中不动点的数量；给出t组数据；在每组数据中，给出一个n，我们需要构造尽可能多的序列，使其不动性依次严格递减。每组数据输出最多的序列数k，然后接下来k行输出这些排列(答案有很多种，满足题意即可...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Educational Codeforces Round 133 (Rated for Div. 2)","slug":"题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2.json"},{"name":"D800","slug":"题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2/D800","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2/D800.json"},{"name":"数学","slug":"题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2/D800/数学","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-133-Rated-for-Div-2/D800/数学.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"Educational Codeforces Round 133 (Rated for Div. 2)","slug":"Educational-Codeforces-Round-133-Rated-for-Div-2","count":1,"path":"api/tags/Educational-Codeforces-Round-133-Rated-for-Div-2.json"},{"name":"D800","slug":"D800","count":4,"path":"api/tags/D800.json"},{"name":"数学","slug":"数学","count":1,"path":"api/tags/数学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">分析思路：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CF1743C.Save the Magazines","uid":"e185d61ae3cd4ae90fd39cfd13028509","slug":"CF1743C.Save the Magazines","date":"2022-11-08T16:00:00.000Z","updated":"2022-11-08T16:00:00.000Z","comments":true,"path":"api/articles/CF1743C.Save the Magazines.json","keywords":"notes","cover":"/images/cf.png","text":"原题链接：CF1743C 题目大意：有个人收集了很多有价值的报纸，分别放在了从编号1到n的n个箱子中，有个箱子有盖子，而有的箱子没有，记第i个箱子中的报纸数为ai;突然！就很突然，下雨了，有盖子的箱子中的报纸不会被淋湿，而没盖子的箱子中报纸会被淋湿，这个人想去拯救尽可能多的报纸，...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Educational Codeforces Round 137 (Rated for Div. 2)","slug":"题记/Codeforces/Educational-Codeforces-Round-137-Rated-for-Div-2","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-137-Rated-for-Div-2.json"},{"name":"D1100","slug":"题记/Codeforces/Educational-Codeforces-Round-137-Rated-for-Div-2/D1100","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-137-Rated-for-Div-2/D1100.json"},{"name":"贪心","slug":"题记/Codeforces/Educational-Codeforces-Round-137-Rated-for-Div-2/D1100/贪心","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-137-Rated-for-Div-2/D1100/贪心.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"贪心","slug":"贪心","count":9,"path":"api/tags/贪心.json"},{"name":"D1100","slug":"D1100","count":2,"path":"api/tags/D1100.json"},{"name":"Educational Codeforces Round 137 (Rated for Div. 2)","slug":"Educational-Codeforces-Round-137-Rated-for-Div-2","count":1,"path":"api/tags/Educational-Codeforces-Round-137-Rated-for-Div-2.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"CF1744D.Divisibility by 2^n","uid":"f43c88fb6011bc7c9f20123aabe01edd","slug":"CF1744D.Divisibility by 2^n","date":"2022-11-07T16:00:00.000Z","updated":"2022-11-07T16:00:00.000Z","comments":true,"path":"api/articles/CF1744D.Divisibility by 2^n.json","keywords":"notes","cover":"/images/cf.png","text":"原题链接:CF1744D 题目大意：共有t组数据，每组数据给出一个n，然后在下一行中给出n个数字a1,a2,…,an。可以执行一种操作：取i∈[1, n]，使得ai&#x3D;aii，对于每个i最多只能执行一次操作。问：操作多少次可以使得Π(pai，求积符号)ai能被2n整除，若...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#828 (Div. 3)","slug":"题记/Codeforces/Codeforces-Round-828-Div-3","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3.json"},{"name":"D1200","slug":"题记/Codeforces/Codeforces-Round-828-Div-3/D1200","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3/D1200.json"},{"name":"贪心","slug":"题记/Codeforces/Codeforces-Round-828-Div-3/D1200/贪心","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3/D1200/贪心.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"贪心","slug":"贪心","count":9,"path":"api/tags/贪心.json"},{"name":"D1200","slug":"D1200","count":2,"path":"api/tags/D1200.json"},{"name":"Codeforces Round#828 (Div. 3)","slug":"Codeforces-Round-828-Div-3","count":2,"path":"api/tags/Codeforces-Round-828-Div-3.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}