{"title":"洛谷P1955[NOI2015]程序自动分析","uid":"911a72b9cf1301cce1d0e6e3bd36166b","slug":"洛谷P1955[NOI2015]程序自动分析","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P1955[NOI2015]程序自动分析.json","keywords":"notes","cover":null,"content":"<p>原题链接<a href=\"https://www.luogu.com.cn/problem/P1955\">LuoguP1955</a><br>用到的知识：<a href=\"\">并查集</a>、<a href=\"https://smtty.github.io/2022/11/07/%E7%A6%BB%E6%95%A3%E5%8C%96/\">离散化</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>总共有t个问题数；每次问题都是独立的，且每个问题都有若干条件，在每个问题中给出一个正整数n，代表条件的关系数，接下来的n行中每行有三个数i, j, e表示约束条件，当e为1时表示条件i &#x3D; 条件j，当e为0时表示条件i ≠ 条件j，问这些约束条件是否能够同时满足，若能输出YES，不能输出NO。<br>数据范围：1 &lt;&#x3D; t &lt;&#x3D; 10，1 &lt;&#x3D; n &lt;&#x3D; 10<sup>6</sup>，1 &lt;&#x3D; i,j &lt;&#x3D; 10<sup>9</sup>，e∈{0, 1}。</p>\n<h3 id=\"分析思路：\"><a href=\"#分析思路：\" class=\"headerlink\" title=\"分析思路：\"></a>分析思路：</h3><p>首先分析问题，如果两个条件相等可以看作在两个点之间连了一条无向边，即条件1&#x3D;条件2，条件2&#x3D;条件3，则可以推导出条件1&#x3D;条件3，可以发现连边可以表示为将两个集合合并，如果不等那么两个条件不处于同一集合，问题可用并查集解决；其次观察数据i,j的范围大小远大于2*n，为了并查集的初始化不超时，我们需要用到离散化去缩小数据范围，并且不需要保序，可以用哈希表进行无序离散化，直接用unordered_map解决离散化，且如果存在相悖条件，一定出现在不相等处，那么就可以先将相等关系合并，然后检查不相等关系是否成立，不成立则所有约束条件不能同时满足，反之可以同时满足。</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;unordered_map&gt;\nusing namespace std;\n\nconst int N &#x3D; 2000010;\n\nunordered_map&lt;int, int&gt; s;\n\nint n, m, q;\nint x[N], y[N], p[N];\n\n&#x2F;&#x2F;离散化加点及查询\nint get(int z)&#123;\n    if (s.count(z) &#x3D;&#x3D; 0)\n        s[z] &#x3D; ++n;\n    return s[z];\n&#125;\n\n&#x2F;&#x2F;并查集\nint find(int z)&#123;\n    if (p[z] !&#x3D; z)\n        p[z] &#x3D; find(p[z]);\n    return p[z];\n&#125;\n\nint main()&#123;\n    int _;\n    scanf(&quot;%d&quot;, &amp;_);\n    while (_ --)&#123;\n        n &#x3D; q &#x3D; 0;\n        s.clear();\n        cin &gt;&gt; m;\n        for (int i &#x3D; 1; i &lt;&#x3D; 2 * m; i ++ )\n            p[i] &#x3D; i;\n\n        for (int i &#x3D; 0; i &lt; m; i ++ )&#123;\n            int a, b, c;\n            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);\n            &#x2F;&#x2F;相等条件先处理，记录不等关系\n            if (c)&#123;\n                a &#x3D; get(a), b &#x3D; get(b);\n                p[find(a)] &#x3D; find(b);\n            &#125;\n            else&#123;\n                x[q] &#x3D; get(a);\n                y[q] &#x3D; get(b);\n                q++;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;检查不等关系是否满足\n        bool f &#x3D; true;\n        for (int i &#x3D; 0; i &lt; q; i ++ )\n            if (find(x[i]) &#x3D;&#x3D; find(y[i]))&#123;\n                f &#x3D; false;\n                break;\n            &#125;\n        \n        if (f)\n            puts(&quot;YES&quot;);\n        else\n            puts(&quot;NO&quot;);\n    &#125;\n&#125;</code></pre>","text":"原题链接LuoguP1955用到的知识：并查集、离散化 题目大意：总共有t个问题数；每次问题都是独立的，且每个问题都有若干条件，在每个问题中给出一个正整数n，代表条件的关系数，接下来的n行中每行有三个数i, j, e表示约束条件，当e为1时表示条件i &#x3D; 条件j，当e为...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":16,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":3,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷绿题","slug":"题记/洛谷/洛谷绿题","count":2,"path":"api/categories/题记/洛谷/洛谷绿题.json"},{"name":"并查集","slug":"题记/洛谷/洛谷绿题/并查集","count":1,"path":"api/categories/题记/洛谷/洛谷绿题/并查集.json"},{"name":"离散化","slug":"题记/洛谷/洛谷绿题/并查集/离散化","count":1,"path":"api/categories/题记/洛谷/洛谷绿题/并查集/离散化.json"}],"tags":[{"name":"题记","slug":"题记","count":16,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":3,"path":"api/tags/洛谷.json"},{"name":"洛谷绿题","slug":"洛谷绿题","count":2,"path":"api/tags/洛谷绿题.json"},{"name":"离散化","slug":"离散化","count":2,"path":"api/tags/离散化.json"},{"name":"并查集","slug":"并查集","count":1,"path":"api/tags/并查集.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">分析思路：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"队列","uid":"1840725987698b4cef5a9ce40df0584c","slug":"队列","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/队列.json","keywords":"notes","cover":null,"text":"普通队列：&#x2F;&#x2F; hh 表示队头，tt表示队尾 int q[N], hh &#x3D; 0, tt &#x3D; -1; &#x2F;&#x2F; 向队尾插入一个数 q[ ++ tt] &#x3D; x; &#x2F;&#x2F; 从队头弹出一个数 hh ++ ...","link":"","photos":[],"count_time":{"symbolsCount":534,"symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"数据结构","slug":"算法模板/数据结构","count":4,"path":"api/categories/算法模板/数据结构.json"},{"name":"队列","slug":"算法模板/数据结构/队列","count":1,"path":"api/categories/算法模板/数据结构/队列.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"数据结构","slug":"数据结构","count":4,"path":"api/tags/数据结构.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CF1754A.Technical Support","uid":"944cbc217b8e8a1f5e95edb3117a8bea","slug":"CF1754A.Technical Support","date":"2022-11-04T16:00:00.000Z","updated":"2022-11-04T16:00:00.000Z","comments":true,"path":"api/articles/CF1754A.Technical Support.json","keywords":"notes","cover":null,"text":"原题链接CF1754A 题目大意：总共有t组数据，每组数据给出一个n，随后给出n个字符，且字符仅为Q或者A。问：所有的Q能否在其后面找到A配对，每个Q、A只能配对一次，能就输出Yes，不能就输出No。数据范围：1 &lt;&#x3D; t &lt;&#x3D; 500，1 &lt...","link":"","photos":[],"count_time":{"symbolsCount":967,"symbolsTime":"1 mins."},"categories":[{"name":"题记","slug":"题记","count":16,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":13,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#829 (Div.2)","slug":"题记/Codeforces/Codeforces-Round-829-Div-2","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-829-Div-2.json"},{"name":"D800","slug":"题记/Codeforces/Codeforces-Round-829-Div-2/D800","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-829-Div-2/D800.json"},{"name":"贪心","slug":"题记/Codeforces/Codeforces-Round-829-Div-2/D800/贪心","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-829-Div-2/D800/贪心.json"}],"tags":[{"name":"题记","slug":"题记","count":16,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":13,"path":"api/tags/codeforces.json"},{"name":"贪心","slug":"贪心","count":9,"path":"api/tags/贪心.json"},{"name":"D800","slug":"D800","count":4,"path":"api/tags/D800.json"},{"name":"Codeforces Round#829 (Div.2)","slug":"Codeforces-Round-829-Div-2","count":2,"path":"api/tags/Codeforces-Round-829-Div-2.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}