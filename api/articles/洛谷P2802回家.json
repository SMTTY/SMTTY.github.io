{"title":"洛谷P2802回家","uid":"739a4c86892ca932c7b320c540dd8272","slug":"洛谷P2802回家","date":"2023-01-11T16:00:00.000Z","updated":"2023-01-11T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P2802回家.json","keywords":"notes","cover":"/images/lg.jpg","content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://www.luogu.com.cn/problem/P2802\">LuoguP2802</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>在一个n*m个方格组成的矩形内，每次可以向上下左右四个方向移动一格，共有五种属性的格子：<br>0. 障碍物（不可行走）</p>\n<ol>\n<li>空地</li>\n<li>起点</li>\n<li>终点</li>\n<li>带有治疗效果的空地<br>（除了障碍物均可自由行走）<br>刚开始时是满血6点，每移动一个需要耗费一点生命值以及一个单位时间；如果血量减为0，那么不能到达其他格子，即当血量为1点时，下一步哪怕是终点或者可以治疗生命，也无法到达，记为死亡；带有治疗效果的空地可以将血量补满；问：能否安全到家，如果能，输出最短需要多长时间，如果不能则输出-1；<br>数据范围：1 &lt;&#x3D; n, m &lt;&#x3D; 9。</li>\n</ol>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>很明显的广搜，跟别的地图题一样；对于广搜的队列中的元素，我们知道到达队头的位置一定小于等于队列中其他位置，那么最短时间等价于最先搜索到3；因为需要维护到达每个点的时间以及血量，我们需要一个结构体方便记录；对于扩列的过程，如果重复到达一个点，而第二次到达时血量更高，那么这种情况也应扩进队列，因为第一次到达该点一定在第二次到达前扩入队列，若能到达终点，则第二次到达无影响，如果不能到达终点，则需要尝试第二次更高血量这种情况，所以需要把标记升级一下，改成上一次到达时的血量，对于严格血量大于的情况我们插入队列，否则不插入，即可解决问题。</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nconst int N &#x3D; 15;\n\nint n, m, sx, sy, ans;\nint g[N][N];\nint st[N][N];\nint fx[4] &#x3D; &#123;0, 0, 1, -1&#125;, fy[4] &#x3D; &#123;1, -1, 0, 0&#125;;\n\nstruct Step&#123;\n    int x, y;\n    int t, hp;&#x2F;&#x2F;记录到达当前点所需时间和剩余血量\n&#125; q[N * N];\n\nvoid bfs()&#123;\n    int hh &#x3D; 0, tt &#x3D; 0;\n    q[0] &#x3D; &#123;sx, sy, 0, 6&#125;;\n\n    while (hh &lt;&#x3D; tt)&#123;\n        Step t &#x3D; q[hh++];\n        if (t.hp &#x3D;&#x3D; 1) continue;&#x2F;&#x2F;血量为1时到不了别的点，直接跳过\n\n        for (int i &#x3D; 0; i &lt; 4; i ++ )&#123;\n            int x &#x3D; t.x + fx[i], y &#x3D; t.y + fy[i];\n            &#x2F;&#x2F;超界不能走\n            if (x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; m)\n                continue;\n            &#x2F;&#x2F;格子0不能走\n            if (!g[x][y]) continue;\n            &#x2F;&#x2F;如果当前血量少于历史到达这点的最大血量则不走\n            if (t.hp - 1 &lt;&#x3D; st[x][y]) continue;\n\n            &#x2F;&#x2F;格子4补满血量\n            if (g[x][y] &#x3D;&#x3D; 4) st[x][y] &#x3D; 6;\n            else st[x][y] &#x3D; t.hp - 1;\n            &#x2F;&#x2F;扩列\n            q[++tt] &#x3D; &#123;x, y, t.t + 1, st[x][y]&#125;;\n            &#x2F;&#x2F;如果到达终点，返回答案\n            if (g[x][y] &#x3D;&#x3D; 3)&#123;\n                ans &#x3D; t.t + 1;\n                return;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    for (int i &#x3D; 0; i &lt; n; i ++ )\n        for (int j &#x3D; 0; j &lt; m; j ++ )&#123;\n            scanf(&quot;%d&quot;, &amp;g[i][j]);\n            if (g[i][j] &#x3D;&#x3D; 2)\n                sx &#x3D; i, sy &#x3D; j;\n        &#125;\n\n    &#x2F;&#x2F;预设答案为-1，如果到不了终点，ans为-1\n    ans &#x3D; -1;\n    bfs();\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n&#125;</code></pre>","feature":false,"text":"原题链接：LuoguP2802 题目大意：在一个n*m个方格组成的矩形内，每次可以向上下左右四个方向移动一格，共有五种属性的格子：0. 障碍物（不可行走） 空地 起点 终点 带有治疗效果的空地（除了障碍物均可自由行走）刚开始时是满血6点，每移动一个需要耗费一点生命值以及一个单位时...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":19,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":5,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷橙题","slug":"题记/洛谷/洛谷橙题","count":2,"path":"api/categories/题记/洛谷/洛谷橙题.json"},{"name":"广搜","slug":"题记/洛谷/洛谷橙题/广搜","count":1,"path":"api/categories/题记/洛谷/洛谷橙题/广搜.json"}],"tags":[{"name":"题记","slug":"题记","count":19,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":5,"path":"api/tags/洛谷.json"},{"name":"洛谷橙题","slug":"洛谷橙题","count":2,"path":"api/tags/洛谷橙题.json"},{"name":"广搜","slug":"广搜","count":1,"path":"api/tags/广搜.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">解题思路：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"线段树整理","uid":"e0aa9ca13b84c518e471c68dfb7b2c45","slug":"线段树整理","date":"2023-01-01T16:00:00.000Z","updated":"2023-01-01T16:00:00.000Z","comments":true,"path":"api/articles/线段树整理.json","keywords":"notes","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"整理","slug":"整理","count":1,"path":"api/categories/整理.json"},{"name":"线段树","slug":"整理/线段树","count":1,"path":"api/categories/整理/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":3,"path":"api/tags/线段树.json"},{"name":"整理","slug":"整理","count":1,"path":"api/tags/整理.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"CF1514D.Cut and Stick","uid":"f075594e00bebf1a5e02003b274b368e","slug":"CF1514D.Cut and Stick","date":"2023-01-04T13:38:47.114Z","updated":"2023-01-07T14:58:00.146Z","comments":true,"path":"api/articles/CF1514D.Cut and Stick.json","keywords":"notes","cover":"/images/cf.png","text":"原题链接：CF1514D 题目大意：给出一个长度为n的序列，可以进行以下操作： 将一些数从原来的区间中剪下来，把这些数重新排成一个或多个区间，最后形成一个或多个区间片段，使得这些区间的所有数恰好是原区间的所有数。 随后给出q次询问，每次询问会给出左右端点，将这个区间分成一个或多个...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"题记","slug":"题记","count":19,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":14,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#716 (Div. 2)","slug":"题记/Codeforces/Codeforces-Round-716-Div-2","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-716-Div-2.json"},{"name":"D2000","slug":"题记/Codeforces/Codeforces-Round-716-Div-2/D2000","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-716-Div-2/D2000.json"},{"name":"线段树","slug":"题记/Codeforces/Codeforces-Round-716-Div-2/D2000/线段树","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-716-Div-2/D2000/线段树.json"},{"name":"莫队","slug":"题记/Codeforces/Codeforces-Round-716-Div-2/D2000/线段树/莫队","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-716-Div-2/D2000/线段树/莫队.json"}],"tags":[{"name":"题记","slug":"题记","count":19,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":14,"path":"api/tags/codeforces.json"},{"name":"线段树","slug":"线段树","count":3,"path":"api/tags/线段树.json"},{"name":"Codeforces Round#716 (Div. 2)","slug":"Codeforces-Round-716-Div-2","count":1,"path":"api/tags/Codeforces-Round-716-Div-2.json"},{"name":"D2000","slug":"D2000","count":1,"path":"api/tags/D2000.json"},{"name":"莫队","slug":"莫队","count":1,"path":"api/tags/莫队.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}