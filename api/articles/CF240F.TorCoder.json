{"title":"CF240F.TorCoder","uid":"8f6e4acfe4f50e2d7064f00009cb5c10","slug":"CF240F.TorCoder","date":"2023-01-15T15:00:59.763Z","updated":"2023-01-27T11:24:17.806Z","comments":true,"path":"api/articles/CF240F.TorCoder.json","keywords":"notes","cover":"/images/cf.png","content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://codeforces.com/problemset/problem/240/F\">CF240F</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>给出一个长度为n的由’a’到’z’组成的字符串，有m次操作，每次操作将[l, r]这些位置的字符进行重排，得到字典序最小的回文字符串，如果无法组成回文字符串，则操作不进行，输出操作m次后的字符串。<br>输入输出要求：从文件 input.txt 中读入数据，输出到文件 output.txt 中。<br>数据范围：1 ≤ n,m ≤ 10<sup>5</sup>，1 ≤ l ≤ r ≤ n。</p>\n<h3 id=\"分析思路：\"><a href=\"#分析思路：\" class=\"headerlink\" title=\"分析思路：\"></a>分析思路：</h3><h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nchar a[N];\nstruct Node&#123;\n    int l, r;\n    int tag;\n    int t[26];\n&#125; tr[N * 4];\n&#x2F;&#x2F;将u节点全部更新为c\ninline void update(int u, int c)&#123;\n    memset(tr[u].t, 0, sizeof tr[u].t);\n    tr[u].t[c] &#x3D; tr[u].r - tr[u].l + 1;\n    tr[u].tag &#x3D; c;\n&#125;\n\ninline void pushup(int u)&#123;\n    for (int i &#x3D; 0; i &lt; 26; i ++ )\n        tr[u].t[i] &#x3D; tr[u &lt;&lt; 1].t[i] + tr[u &lt;&lt; 1 | 1].t[i];\n&#125;\n\ninline void pushdown(int u)&#123;\n    if (tr[u].tag &#x3D;&#x3D; -1) return;\n    update(u &lt;&lt; 1, tr[u].tag);\n    update(u &lt;&lt; 1 | 1, tr[u].tag);\n    tr[u].tag &#x3D; -1;\n&#125;\n\nvoid build(int u, int l, int r)&#123;\n    tr[u] &#x3D; &#123;l, r, -1&#125;;\n    if (l &#x3D;&#x3D; r)&#123;\n        tr[u].t[a[l] - &#39;a&#39;]++;\n        tr[u].tag &#x3D; a[l] - &#39;a&#39;;\n        return;\n    &#125;\n    int mid &#x3D; l + r &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n    pushup(u);\n&#125;\n\nvoid modify(int u, int l, int r, int c)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        update(u, c);\n    else&#123;\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        pushdown(u);\n        if (l &lt;&#x3D; mid)\n            modify(u &lt;&lt; 1, l, r, c);\n        if (r &gt; mid)\n            modify(u &lt;&lt; 1 | 1, l, r, c);\n        pushup(u);\n    &#125;\n&#125;\n\nvoid query(int cnt[], int u, int l, int r)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        for (int i &#x3D; 0; i &lt; 26; i ++ )\n            cnt[i] +&#x3D; tr[u].t[i];\n    else&#123;\n        pushdown(u);\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        if (l &lt;&#x3D; mid)\n            query(cnt, u &lt;&lt; 1, l, r);\n        if (r &gt; mid)\n            query(cnt, u &lt;&lt; 1 | 1, l, r);\n    &#125;\n&#125;\n\nvoid operate()&#123;\n    int l, r;\n    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);\n    int len &#x3D; r - l + 1, odd &#x3D; 0, p &#x3D; -1, cnt[26] &#x3D; &#123;&#125;;\n    query(cnt, 1, l, r);\n    for (int i &#x3D; 0; i &lt; 26; i ++ )\n        if (cnt[i] &amp; 1)\n            odd++, p &#x3D; i;\n    if ((odd &#x3D;&#x3D; 1) &amp;&amp; (len &amp; 1))&#123;\n        &#x2F;&#x2F;都是奇数\n        int j &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; 26; i ++ )&#123;\n            if (!cnt[i]) continue;\n\n            modify(1, l + j - 1, l + j - 1 + cnt[i] &#x2F; 2, i);\n            modify(1, r - j + 1 - cnt[i] &#x2F; 2, r - j + 1, i);\n            j +&#x3D; cnt[i] &#x2F; 2;\n        &#125;\n        modify(1, l + j - 1, l + j - 1, p);\n    &#125;else if(odd &#x3D;&#x3D; 0 &amp;&amp; ((len ^ 1) &amp; 1))&#123;\n        &#x2F;&#x2F;都是偶数\n        int j &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; 26; i ++ )&#123;\n            if (!cnt[i]) continue;\n\n            modify(1, l + j - 1, l + j - 1 + cnt[i] &#x2F; 2, i);\n            modify(1, r - j + 1 - cnt[i] &#x2F; 2, r - j + 1, i);\n            j +&#x3D; cnt[i] &#x2F; 2;\n        &#125;\n    &#125;\n&#125;\n\nvoid printtree(int u, int l, int r)&#123;\n    if (l &#x3D;&#x3D; r)&#123;\n        printf(&quot;%c&quot;, tr[u].tag + &#39;a&#39;);\n        return;\n    &#125;\n    int mid &#x3D; l + r &gt;&gt; 1;\n    pushdown(u);\n    printtree(u &lt;&lt; 1, l, mid), printtree(u &lt;&lt; 1 | 1, mid + 1, r);\n&#125;\n\nint main()&#123;\n    freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);\n    freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout);\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    scanf(&quot;%s&quot;, a + 1);\n\n    build(1, 1, n);\n\n    while (m -- )    \n        operate();\n\n    printtree(1, 1, n);\n&#125;</code></pre>","feature":false,"text":"原题链接：CF240F 题目大意：给出一个长度为n的由’a’到’z’组成的字符串，有m次操作，每次操作将[l, r]这些位置的字符进行重排，得到字典序最小的回文字符串，如果无法组成回文字符串，则操作不进行，输出操作m次后的字符串。输入输出要求：从文件 input.txt 中读入数...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#145 (Div. 1, ACM-ICPC Rules)","slug":"题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules.json"},{"name":"D2600","slug":"题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules/D2600","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules/D2600.json"},{"name":"线段树","slug":"题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules/D2600/线段树","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules/D2600/线段树.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"线段树","slug":"线段树","count":5,"path":"api/tags/线段树.json"},{"name":"Codeforces Round#145 (Div. 1, ACM-ICPC Rules)","slug":"Codeforces-Round-145-Div-1-ACM-ICPC-Rules","count":1,"path":"api/tags/Codeforces-Round-145-Div-1-ACM-ICPC-Rules.json"},{"name":"D2600","slug":"D2600","count":1,"path":"api/tags/D2600.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">分析思路：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"D.Chat Program","uid":"8b78cc765c53e033e18243f7d6ac7be7","slug":"2022icpcnanjingD.Chat Program","date":"2023-01-27T10:44:57.940Z","updated":"2023-01-31T10:23:18.216Z","comments":true,"path":"api/articles/2022icpcnanjingD.Chat Program.json","keywords":"notes","cover":"/images/icpc.png","text":"链接：测试链接中文题面在这里面找 题目大意：题面很长，说人话就是，给一个长n的序列a，另外给出k,m,c,d四个整数，我们可以选择序列中的一个位置p(1 ≤ p ≤ n - m + 1)，并对于所有0 ≤ i &lt; m，将ap+i增加(c + di)，求至多进行一次操作后，序...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"icpc","slug":"题记/icpc","count":2,"path":"api/categories/题记/icpc.json"},{"name":"The 2022 ICPC Asia Nanjing Regional Contest","slug":"题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest","count":2,"path":"api/categories/题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest.json"},{"name":"差分","slug":"题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest/差分","count":2,"path":"api/categories/题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest/差分.json"},{"name":"二分答案","slug":"题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest/差分/二分答案","count":1,"path":"api/categories/题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest/差分/二分答案.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"icpc","slug":"icpc","count":2,"path":"api/tags/icpc.json"},{"name":"The 2022 ICPC Asia Nanjing Regional Contest","slug":"The-2022-ICPC-Asia-Nanjing-Regional-Contest","count":2,"path":"api/tags/The-2022-ICPC-Asia-Nanjing-Regional-Contest.json"},{"name":"差分","slug":"差分","count":3,"path":"api/tags/差分.json"},{"name":"二分答案","slug":"二分答案","count":2,"path":"api/tags/二分答案.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"CF242E.XOR on Segment","uid":"50b31c65d3a0ab42e18780b1693a66e7","slug":"CF242E.XOR on Segment","date":"2023-01-14T12:24:15.132Z","updated":"2023-01-27T11:38:21.281Z","comments":true,"path":"api/articles/CF242E.XOR on Segment.json","keywords":"notes","cover":"/images/cf.png","text":"原题链接：CF242E 题目大意：维护长度为n的序列a，并支持两张操作： 求区间[l, r]的元素和(以op,l,r输入) 把区间[l, r]的元素分别异或上x(以op,l,r,x输入)输入格式：第一行一个n表示序列长度，第二行是长度为n的序列；第三行m表示操作的个数，接下来m行...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#149 (Div. 2)","slug":"题记/Codeforces/Codeforces-Round-149-Div-2","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-149-Div-2.json"},{"name":"D2000","slug":"题记/Codeforces/Codeforces-Round-149-Div-2/D2000","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-149-Div-2/D2000.json"},{"name":"线段树","slug":"题记/Codeforces/Codeforces-Round-149-Div-2/D2000/线段树","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-149-Div-2/D2000/线段树.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"D2000","slug":"D2000","count":2,"path":"api/tags/D2000.json"},{"name":"线段树","slug":"线段树","count":5,"path":"api/tags/线段树.json"},{"name":"Codeforces Round#149 (Div. 2)","slug":"Codeforces-Round-149-Div-2","count":1,"path":"api/tags/Codeforces-Round-149-Div-2.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}