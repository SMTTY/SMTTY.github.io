{"title":"洛谷P4145上帝造题的七分钟2/花神游历各国","uid":"82c5266900e554d28363dfa4bc63c789","slug":"洛谷P4145上帝造题的七分钟2 花神游历各国","date":"2023-01-01T16:00:00.000Z","updated":"2023-01-01T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P4145上帝造题的七分钟2 花神游历各国.json","keywords":"notes","cover":null,"content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://www.luogu.com.cn/problem/P4145\">LuoguP4145</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>首先第一行给出一个数字n，随后在下一行给出的n个整数作为初始数列，第三行给出一个m，代表有m个操作，在接下来的m行，每行包含三个整数k,l,r，其中k表示操作：</p>\n<ol>\n<li>k &#x3D; 0，表示给[l, r]区间内每个元素开平方(向下取整)。</li>\n<li>k &#x3D; 1，表示询问区间[l, r]内的元素和。<br>数据范围：1 &lt;&#x3D; n, m &lt;&#x3D; 10<sup>3</sup>，1 &lt;&#x3D; l, r &lt;&#x3D; n，数列中的数大于0，且不超过10<sup>12</sup>。<br>注意：如果遇到l &gt; r的情况，需要交换l，r。</li>\n</ol>\n<h3 id=\"线段树解法：\"><a href=\"#线段树解法：\" class=\"headerlink\" title=\"线段树解法：\"></a>线段树解法：</h3><p>维护区间和，并且支持修改和询问操作，很难不想到线段树；<br>但此时出现一个问题，对于修改我们通常会使用懒标记，但因为操作是开方且向下取整，显然每个元素先开方再求和不等于它们的和开方，那么对于每一次操作必须下放到每一个元素，那么如果懒标记，那么只能统计开放次数，不难发现意义不大；<br>从上面分析中，不难看出每次操作需要下放到每个元素，又m &lt;&#x3D; 10<sup>5</sup>，且10<sup>12</sup>的数开方6次就变成1了，可知下放到每个元素是可行的；由数学知识，我们可以知道，当元素等于1的时候，无论如何开方，值仍为一，如果某一区间仅含有元素1，那么该区间执行操作前后值是一定不变的，此时就不用再向下递归去修改元素；对于判断区间是否全为1，可以维护区间长度，或者维护区间最大值，（我维护的是区间长度，就不提供维护区间最大值的代码了，仅需在上传pushup操作中加一个max左右儿子最大值即可）。</p>\n<h3 id=\"线段树代码如下：\"><a href=\"#线段树代码如下：\" class=\"headerlink\" title=\"线段树代码如下：\"></a>线段树代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nll w[N];\n\nstruct Node&#123;\n    int l, r;\n    ll sum, len;\n&#125; tr[N * 4];\n\nvoid pushup(int u)&#123;\n    tr[u].sum &#x3D; tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;\n&#125;\n\nvoid build(int u, int l, int r)&#123;\n    tr[u] &#x3D; &#123;l, r, w[r], r - l + 1&#125;;\n    if (l !&#x3D; r)&#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(u);\n    &#125;\n&#125;\n\nvoid modify(int u, int l, int r)&#123;\n    if (tr[u].len &#x3D;&#x3D; tr[u].sum) return;\n    &#x2F;&#x2F;如果区间元素均为1，则不需要继续向下递归\n\n    if (tr[u].l &#x3D;&#x3D; tr[u].r)&#123;\n        tr[u].sum &#x3D; sqrt(tr[u].sum);\n        return;\n    &#125;\n    &#x2F;&#x2F;如果已经修改到叶子节点，没有下一级继续去递归\n\n    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n    if (l &lt;&#x3D; mid)\n        modify(u &lt;&lt; 1, l, r);\n    if (r &gt; mid)\n        modify(u &lt;&lt; 1 | 1, l, r);\n    pushup(u);\n    &#x2F;&#x2F;记得上传计算sum\n&#125;\n\nll query(int u, int l, int r)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        return tr[u].sum;\n    else&#123;\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        ll res &#x3D; 0;\n        if (l &lt;&#x3D; mid)\n            res &#x3D; query(u &lt;&lt; 1, l, r);\n        if (r &gt; mid)\n            res +&#x3D; query(u &lt;&lt; 1 | 1, l, r);\n        return res;\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        scanf(&quot;%lld&quot;, &amp;w[i]);\n\n    build(1, 1, n);\n\n    scanf(&quot;%d&quot;, &amp;m);\n    int op, l, r;\n    while (m -- )&#123;\n        scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r);\n        if (l &gt; r) swap(l, r);\n        if (op &#x3D;&#x3D; 0) modify(1, l, r);\n        else printf(&quot;%lld\\n&quot;, query(1, l, r));\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"树状数组-amp-并查集解法：\"><a href=\"#树状数组-amp-并查集解法：\" class=\"headerlink\" title=\"树状数组&amp;并查集解法：\"></a>树状数组&amp;并查集解法：</h3><p>对数据范围进行分析，m &lt;&#x3D; 10<sup>5</sup>，元素最大可以取到10<sup>12</sup>，而它仅需要开方6次就可以变成1，因此可以对每个元素修改；对于访问区间和，我们不难想到前缀和，而又需要修改操作，那么树状数组就可以满足我们的需要，对于每个元素，我们仅需要将修改后减去修改前得到的值，加到那个元素的位置即可；<br>如果元素为1的话，那我们可以不进行修改操作，并且可以跳过所有元素为1的位置，此时，我们只需要将连续的1，以及其后一个位置放到一个连通块中，并且紧挨着这一串1，不为1的第一个数(或者结尾，即n+1位置)作为祖宗节点，这样，我们如果需要跳过一串1则可以通过将指针移到祖宗节点即可；那么对于，修改后为1的元素，我们将他的祖宗节点指向下一元素即可。</p>\n<h3 id=\"树状数组-amp-并查集代码如下：\"><a href=\"#树状数组-amp-并查集代码如下：\" class=\"headerlink\" title=\"树状数组&amp;并查集代码如下：\"></a>树状数组&amp;并查集代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N &#x3D; 100010;\n\nll tr[N], a[N];\nint p[N], n, m;\n&#x2F;&#x2F;并查集\ninline int find(int x)&#123;\n    if (p[x] !&#x3D; x)\n        p[x] &#x3D; find(p[x]);\n    return p[x];\n&#125;\n&#x2F;&#x2F;返回x二进制中最后一个1的位置\ninline int lowbit(int x)&#123;\n    return x &amp; -x;\n&#125;\n&#x2F;&#x2F;树状数组修改操作\ninline void add(int x, ll c)&#123;\n    for (int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i))\n        tr[i] +&#x3D; c;\n&#125;\n&#x2F;&#x2F;树状数组求和\ninline ll sum(int x)&#123;\n    ll res &#x3D; 0;\n    for (int i &#x3D; x; i; i -&#x3D; lowbit(i))\n        res +&#x3D; tr[i];\n    return res;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n        scanf(&quot;%lld&quot;, &amp;a[i]);\n        add(i, a[i]);\n        p[i] &#x3D; i;\n    &#125;\n    scanf(&quot;%d&quot;, &amp;m);\n    p[n + 1] &#x3D; n + 1; \n    &#x2F;&#x2F;需要用到数列后面的一个点，因为他可能成为数列后缀的祖宗节点\n\n    int k, l, r;\n    ll t;\n    while(m -- ) &#123;\n        scanf(&quot;%d%d%d&quot;, &amp;k, &amp;l, &amp;r);\n        if (l &gt; r) swap(l, r);\n        if (k) printf(&quot;%lld\\n&quot;, sum(r) - sum(l - 1));\n        else\n            while(l &lt;&#x3D; r)&#123;\n                t &#x3D; (ll) sqrt(a[l]);\n                add(l, t - a[l]);&#x2F;&#x2F;修改树状数组\n                a[l] &#x3D; t;&#x2F;&#x2F;修改元素\n                if (t &#x3D;&#x3D; 1)\n                    p[l] &#x3D; l + 1, l &#x3D; find(l);\n                &#x2F;&#x2F;如果修改后值变为1，则需要将他合并到后一元素，并将指针移向其祖宗节点\n                else l++;\n                &#x2F;&#x2F;否则遍历下一元素\n            &#125;\n        &#125;\n\n&#125;</code></pre>","feature":true,"text":"原题链接：LuoguP4145 题目大意：首先第一行给出一个数字n，随后在下一行给出的n个整数作为初始数列，第三行给出一个m，代表有m个操作，在接下来的m行，每行包含三个整数k,l,r，其中k表示操作： k &#x3D; 0，表示给[l, r]区间内每个元素开平方(向下取整)。 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"题记","slug":"题记","count":17,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":4,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷蓝题","slug":"题记/洛谷/洛谷蓝题","count":1,"path":"api/categories/题记/洛谷/洛谷蓝题.json"},{"name":"线段树","slug":"题记/洛谷/洛谷蓝题/线段树","count":1,"path":"api/categories/题记/洛谷/洛谷蓝题/线段树.json"}],"tags":[{"name":"题记","slug":"题记","count":17,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":4,"path":"api/tags/洛谷.json"},{"name":"洛谷蓝题","slug":"洛谷蓝题","count":1,"path":"api/tags/洛谷蓝题.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%A7%A3%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">线段树解法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">线段树代码如下：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-amp-%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">树状数组&amp;并查集解法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-amp-%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">树状数组&amp;并查集代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"线段树整理","uid":"e0aa9ca13b84c518e471c68dfb7b2c45","slug":"线段树整理","date":"2023-01-01T16:00:00.000Z","updated":"2023-01-01T16:00:00.000Z","comments":true,"path":"api/articles/线段树整理.json","keywords":"notes","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"整理","slug":"整理","count":1,"path":"api/categories/整理.json"},{"name":"线段树","slug":"整理/线段树","count":1,"path":"api/categories/整理/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"整理","slug":"整理","count":1,"path":"api/tags/整理.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}