{"title":"CF1514D.Cut and Stick","uid":"f075594e00bebf1a5e02003b274b368e","slug":"CF1514D.Cut and Stick","date":"2023-01-04T13:38:47.114Z","updated":"2023-01-14T12:47:27.677Z","comments":true,"path":"api/articles/CF1514D.Cut and Stick.json","keywords":"notes","cover":"/images/cf.png","content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://codeforces.com/contest/1514/problem/D\">CF1514D</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>给出一个长度为n的序列，可以进行以下操作：</p>\n<ul>\n<li>将一些数从原来的区间中剪下来，把这些数重新排成一个或多个区间，最后形成一个或多个区间片段，使得这些区间的所有数恰好是原区间的所有数。</li>\n</ul>\n<p>随后给出q次询问，每次询问会给出左右端点，将这个区间分成一个或多个区间片段，使得每个片段内，任意元素出现的次数不严格大于[(x + 1)&#x2F;2]（x表示任意元素出现的次数,[]表示向下取整；即x&#x2F;2向上取整），输出满足条件可以分成的最小片段数。</p>\n<p>数据范围：1 &lt;&#x3D; n,q &lt;&#x3D; 3*10<sup>5</sup>，1 &lt;&#x3D; a<sub>i</sub> &lt;&#x3D; n，1 &lt;&#x3D; l &lt;&#x3D; r &lt;&#x3D; n。</p>\n<h3 id=\"线段树解法：\"><a href=\"#线段树解法：\" class=\"headerlink\" title=\"线段树解法：\"></a>线段树解法：</h3><p>首先说，线段树维护众数是不好维护的，但这个题，我们需要获取的是超过区间长度一半的众数，那也就是说，如果这个区间的众数没有超过区间长度的一半，就可以不用分段，换而言之，此时区间的众数对结果没有任何影响，所以我们只需要维护超过区间长度一半的众数即可。<br>接下来就是用线段树去维护超过区间长度一半的众数：</p>\n<ol>\n<li>先考虑如何获取一段区间内某个数字出现的次数，我们可以通过存储每个数字出现的位置，每个数字用一个vector数组去存储，然后用Lower_bound去获取大于等于左端点l的第一个位置，然后再用upper_bound获取大于右端点r的第一个位置，此时，二者的差值就是这个数字在[l, r]内出现的次数，注意右端点处要用upper_bound，因为出现长度的计算原理应该是 出现的最后一次 - 出现的第一次 + 1，而Lower_bound无法判断最后一次出现的位置是恰好在r，还是严格大于r，所以我们只需用upper_bound找到严格大于r的第一次出现，再减去1，即为出现次数。</li>\n<li>其次就是这个题为什么能用线段树做的原因之一，我们所需要维护的是超过区间长度一半的众数，也就是说如果这个区间内。任何数字没有超过区间长度一半的话，那我维护出来的结果不是众数也没有关系；所以线段树的上传操作，仅需比较两儿子的众数，不用考虑可能新产生众数，因为如果新产生的众数不是两儿子任意一个的众数，很容易证得它没有超过区间长度的一半。</li>\n</ol>\n<p>超过区间长度一半的众数维护出来之后，就需要对答案计算公式进行推导：</p>\n<ol>\n<li>众数小于区间长度一半，则不用分段，答案为1，输出即可。</li>\n<li>众数大于区间长度一半时，设众数为x，除了众数的其他数字为y，区间长度为len，那么len &#x3D; x + y，不难发现每一个y至多消耗2个x，此时我们需要对x,y的关系进行讨论：<br>(1).x &gt;&#x3D; 2y时，即每两个众数和一个其他数配对后，众数仍有剩余，此时剩余的众数每个需要单独一个区间片段，通过计算很容易得到x<sub>余</sub>&#x3D;len-2y-y&#x3D;len-3y，已经分好的片段数为y，那么区间片段数就是x<sub>余</sub>+y，将x+y&#x3D;len代入得结果为2x-len；<br>(2).x &lt; 2y时，此时剩余的是除了众数的其他数，不难发现，每一个其他数，可以使两个由2x+y构成的区间合并，通过计算易得y<sub>余</sub>&#x3D;y - x&#x2F;2，已经分好的片段数为x&#x2F;2，那么区间片段数就应该是x&#x2F;2 - y<sub>余</sub>，化简得结果仍为2x-len；(没有对x进行奇偶讨论，很容易得出，x无论奇偶，推导出的答案仍为2x-len)<br>综上，我们得出了结果的计算公式，如果众数未超出区间长度的一半，答案为1，如果超出区间长度的一半，答案为2x-len。</li>\n</ol>\n<h3 id=\"线段树代码：\"><a href=\"#线段树代码：\" class=\"headerlink\" title=\"线段树代码：\"></a>线段树代码：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int N &#x3D; 300010;\n\nvector&lt;int&gt; p[N];\n\nint n, q;\nint w[N];\n\nstruct Node&#123;\n    int l, r;\n    int x;\n&#125; tr[N * 4];\n&#x2F;&#x2F;获取区间[l, r]内x出现的次数，upper_bound的原因解法中有解释\ninline int num(int l, int r, int x)&#123;\n    if (x &#x3D;&#x3D; 0) return 0;\n    return upper_bound(p[x].begin(), p[x].end(), r) -\n           lower_bound(p[x].begin(), p[x].end(), l);\n&#125;\n&#x2F;&#x2F;用于比较节点u左右儿子众数的函数\ninline bool compare(int u)&#123;\n    int lx &#x3D; num(tr[u &lt;&lt; 1].l, tr[u &lt;&lt; 1].r, tr[u &lt;&lt; 1].x),\n        rx &#x3D; num(tr[u &lt;&lt; 1 | 1].l, tr[u &lt;&lt; 1 | 1].r, tr[u &lt;&lt; 1 | 1].x);\n    return lx &gt; rx;\n&#125;\n\ninline void pushup(int u)&#123;\n    if (compare(u)) tr[u].x &#x3D; tr[u &lt;&lt; 1].x;\n    else tr[u].x &#x3D; tr[u &lt;&lt; 1 | 1].x;\n&#125;\n\nvoid build(int u, int l, int r)&#123;\n    tr[u] &#x3D; &#123;l, r, w[r]&#125;;\n    if (l !&#x3D; r)&#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n        pushup(u);\n    &#125;\n&#125;\n\nint query(int u, int l, int r)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r) return tr[u].x;\n    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1, x &#x3D; 0;\n    if (l &lt;&#x3D; mid) x &#x3D; query(u &lt;&lt; 1, l, r);\n    if (r &gt; mid)&#123;\n        int y &#x3D; query(u &lt;&lt; 1 | 1, l, r);\n        if (num(l,r,x) &lt;&#x3D; num(l,r,y)) x &#x3D; y;\n    &#125;\n    return x;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n        scanf(&quot;%d&quot;, &amp;w[i]);\n        p[w[i]].push_back(i);\n    &#125;\n\n    build(1, 1, n);\n\n    int l, r;\n    while (q -- )&#123;\n        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);\n        int t &#x3D; query(1, l, r), len &#x3D; r - l + 1, mid &#x3D; (len + 1) &#x2F; 2, x &#x3D; num(l, r, t);\n        if (x &gt; mid)&#x2F;&#x2F;x超过区间长度一半，答案为2x-len\n            printf(&quot;%d\\n&quot;, 2 * x - len);\n        else puts(&quot;1&quot;);&#x2F;&#x2F;否则答案为1\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"莫队解法：\"><a href=\"#莫队解法：\" class=\"headerlink\" title=\"莫队解法：\"></a>莫队解法：</h3><p>还不会莫队，以后学了再填坑..</p>\n","feature":false,"text":"原题链接：CF1514D 题目大意：给出一个长度为n的序列，可以进行以下操作： 将一些数从原来的区间中剪下来，把这些数重新排成一个或多个区间，最后形成一个或多个区间片段，使得这些区间的所有数恰好是原区间的所有数。 随后给出q次询问，每次询问会给出左右端点，将这个区间分成一个或多个...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"题记","slug":"题记","count":20,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":15,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#716 (Div. 2)","slug":"题记/Codeforces/Codeforces-Round-716-Div-2","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-716-Div-2.json"},{"name":"D2000","slug":"题记/Codeforces/Codeforces-Round-716-Div-2/D2000","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-716-Div-2/D2000.json"},{"name":"线段树","slug":"题记/Codeforces/Codeforces-Round-716-Div-2/D2000/线段树","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-716-Div-2/D2000/线段树.json"},{"name":"莫队","slug":"题记/Codeforces/Codeforces-Round-716-Div-2/D2000/线段树/莫队","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-716-Div-2/D2000/线段树/莫队.json"}],"tags":[{"name":"题记","slug":"题记","count":20,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":15,"path":"api/tags/codeforces.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"Codeforces Round#716 (Div. 2)","slug":"Codeforces-Round-716-Div-2","count":1,"path":"api/tags/Codeforces-Round-716-Div-2.json"},{"name":"D2000","slug":"D2000","count":2,"path":"api/tags/D2000.json"},{"name":"莫队","slug":"莫队","count":1,"path":"api/tags/莫队.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%A7%A3%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">线段树解法：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">线段树代码：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%AB%E9%98%9F%E8%A7%A3%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">莫队解法：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"洛谷P2802回家","uid":"739a4c86892ca932c7b320c540dd8272","slug":"洛谷P2802回家","date":"2023-01-11T16:00:00.000Z","updated":"2023-01-11T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P2802回家.json","keywords":"notes","cover":"/images/lg.jpg","text":"原题链接：LuoguP2802 题目大意：在一个n*m个方格组成的矩形内，每次可以向上下左右四个方向移动一格，共有五种属性的格子：0. 障碍物（不可行走） 空地 起点 终点 带有治疗效果的空地（除了障碍物均可自由行走）刚开始时是满血6点，每移动一个需要耗费一点生命值以及一个单位时...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":20,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":5,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷橙题","slug":"题记/洛谷/洛谷橙题","count":2,"path":"api/categories/题记/洛谷/洛谷橙题.json"},{"name":"广搜","slug":"题记/洛谷/洛谷橙题/广搜","count":1,"path":"api/categories/题记/洛谷/洛谷橙题/广搜.json"}],"tags":[{"name":"题记","slug":"题记","count":20,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":5,"path":"api/tags/洛谷.json"},{"name":"洛谷橙题","slug":"洛谷橙题","count":2,"path":"api/tags/洛谷橙题.json"},{"name":"广搜","slug":"广搜","count":1,"path":"api/tags/广搜.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"洛谷P4145上帝造题的七分钟2/花神游历各国","uid":"82c5266900e554d28363dfa4bc63c789","slug":"洛谷P4145上帝造题的七分钟2 花神游历各国","date":"2023-01-01T16:00:00.000Z","updated":"2023-01-01T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P4145上帝造题的七分钟2 花神游历各国.json","keywords":"notes","cover":"/images/lg.jpg","text":"原题链接：LuoguP4145 题目大意：首先第一行给出一个数字n，随后在下一行给出的n个整数作为初始数列，第三行给出一个m，代表有m个操作，在接下来的m行，每行包含三个整数k,l,r，其中k表示操作： k &#x3D; 0，表示给[l, r]区间内每个元素开平方(向下取整)。 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"题记","slug":"题记","count":20,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":5,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷蓝题","slug":"题记/洛谷/洛谷蓝题","count":1,"path":"api/categories/题记/洛谷/洛谷蓝题.json"},{"name":"线段树","slug":"题记/洛谷/洛谷蓝题/线段树","count":1,"path":"api/categories/题记/洛谷/洛谷蓝题/线段树.json"}],"tags":[{"name":"题记","slug":"题记","count":20,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":5,"path":"api/tags/洛谷.json"},{"name":"洛谷蓝题","slug":"洛谷蓝题","count":1,"path":"api/tags/洛谷蓝题.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}