{"title":"离散化","uid":"7f00768b865696d227f7b794a43f7717","slug":"离散化","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/离散化.json","keywords":"notes","cover":null,"content":"<p>对于一个非常大的数据范围内，需要使用的值远远小于数据范围的时候，需要用离散化去优化，即将所有需要用到的值映射到一个小的数据范围中。其中有的题的离散化需要保序，即若x&lt;y，则离散化后x’&lt;y’也要成立；而有的题则不需要保序，可以用哈希表去进行映射操作，花费时间更少。</p>\n<h3 id=\"保序离散化板子：\"><a href=\"#保序离散化板子：\" class=\"headerlink\" title=\"保序离散化板子：\"></a>保序离散化板子：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值\nsort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序\nalls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素\n\n&#x2F;&#x2F; 二分求出x对应的离散化的值\nint find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置\n&#123;\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while (l &lt; r)\n    &#123;\n        int mid &#x3D; l + r &gt;&gt; 1;\n        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n\n&#125;</code></pre>\n\n<p>若环境不支持unique函数则需要手写：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;vector需先排序\nvector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a)&#123;\n    int j &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; a.size(); i ++ )\n        if (!i || a[i] !&#x3D; a[i - 1])\n            a[j ++ ] &#x3D; a[i];\n    &#x2F;&#x2F; a[0] ~ a[j - 1]所有a中不重复的数\n\n    return a.begin() + j;\n&#125;</code></pre>\n\n<h3 id=\"无序离散化板子：\"><a href=\"#无序离散化板子：\" class=\"headerlink\" title=\"无序离散化板子：\"></a>无序离散化板子：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;unordered_map的内部实现是哈希表，直接调用\n&#x2F;&#x2F;插入+调用一个函数解决\nint get(int z)&#123;\n    if (s.count(z) &#x3D;&#x3D; 0)\n        s[z] &#x3D; ++n;\n    return s[z];\n&#125;</code></pre>\n\n<p>手写的哈希表链接：<a href=\"\">哈希表</a></p>\n","feature":false,"text":"对于一个非常大的数据范围内，需要使用的值远远小于数据范围的时候，需要用离散化去优化，即将所有需要用到的值映射到一个小的数据范围中。其中有的题的离散化需要保序，即若x&lt;y，则离散化后x’&lt;y’也要成立；而有的题则不需要保序，可以用哈希表去进行映射操作，花费时间更少。 保...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"离散化","slug":"算法模板/离散化","count":1,"path":"api/categories/算法模板/离散化.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"离散化","slug":"离散化","count":2,"path":"api/tags/离散化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E5%BA%8F%E7%A6%BB%E6%95%A3%E5%8C%96%E6%9D%BF%E5%AD%90%EF%BC%9A\"><span class=\"toc-text\">保序离散化板子：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A0%E5%BA%8F%E7%A6%BB%E6%95%A3%E5%8C%96%E6%9D%BF%E5%AD%90%EF%BC%9A\"><span class=\"toc-text\">无序离散化板子：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"洛谷P1955[NOI2015]程序自动分析","uid":"911a72b9cf1301cce1d0e6e3bd36166b","slug":"洛谷P1955[NOI2015]程序自动分析","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P1955[NOI2015]程序自动分析.json","keywords":"notes","cover":null,"text":"原题链接LuoguP1955用到的知识：并查集、离散化 题目大意：总共有t个问题数；每次问题都是独立的，且每个问题都有若干条件，在每个问题中给出一个正整数n，代表条件的关系数，接下来的n行中每行有三个数i, j, e表示约束条件，当e为1时表示条件i &#x3D; 条件j，当e为...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":18,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":4,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷绿题","slug":"题记/洛谷/洛谷绿题","count":2,"path":"api/categories/题记/洛谷/洛谷绿题.json"},{"name":"并查集","slug":"题记/洛谷/洛谷绿题/并查集","count":1,"path":"api/categories/题记/洛谷/洛谷绿题/并查集.json"},{"name":"离散化","slug":"题记/洛谷/洛谷绿题/并查集/离散化","count":1,"path":"api/categories/题记/洛谷/洛谷绿题/并查集/离散化.json"}],"tags":[{"name":"题记","slug":"题记","count":18,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":4,"path":"api/tags/洛谷.json"},{"name":"洛谷绿题","slug":"洛谷绿题","count":2,"path":"api/tags/洛谷绿题.json"},{"name":"并查集","slug":"并查集","count":1,"path":"api/tags/并查集.json"},{"name":"离散化","slug":"离散化","count":2,"path":"api/tags/离散化.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"队列","uid":"1840725987698b4cef5a9ce40df0584c","slug":"队列","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/队列.json","keywords":"notes","cover":null,"text":"普通队列：&#x2F;&#x2F; hh 表示队头，tt表示队尾 int q[N], hh &#x3D; 0, tt &#x3D; -1; &#x2F;&#x2F; 向队尾插入一个数 q[ ++ tt] &#x3D; x; &#x2F;&#x2F; 从队头弹出一个数 hh ++ ...","link":"","photos":[],"count_time":{"symbolsCount":534,"symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"数据结构","slug":"算法模板/数据结构","count":4,"path":"api/categories/算法模板/数据结构.json"},{"name":"队列","slug":"算法模板/数据结构/队列","count":1,"path":"api/categories/算法模板/数据结构/队列.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"数据结构","slug":"数据结构","count":4,"path":"api/tags/数据结构.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}