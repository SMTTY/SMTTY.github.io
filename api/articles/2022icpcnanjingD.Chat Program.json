{"title":"D.Chat Program","uid":"8b78cc765c53e033e18243f7d6ac7be7","slug":"2022icpcnanjingD.Chat Program","date":"2023-01-27T10:44:57.940Z","updated":"2023-01-28T10:42:30.789Z","comments":true,"path":"api/articles/2022icpcnanjingD.Chat Program.json","keywords":"notes","cover":"/images/icpc.png","content":"<h3 id=\"测试链接：\"><a href=\"#测试链接：\" class=\"headerlink\" title=\"测试链接：\"></a>测试链接：</h3><p><a href=\"https://codeforces.com/gym/104128/problem/D\">D.Chat Program</a><br><a href=\"https://codeforces.com/gym/104128/attachments/download/18620/contest-zh.pdf\">中文题面在这里面找</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>题面很长，说人话就是，给一个长n的序列a，另外给出k,m,c,d四个整数，我们可以选择序列中的一个位置p(1 ≤ p ≤ n - m + 1)，并对于所有0 ≤ i &lt; m，将a<sub>p+i</sub>增加(c + di)，求至多进行一次操作后，序列中第k大的值最大可能为多少。<br>数据范围：1 ≤ k, m ≤ n ≤ 2 × 10<sup>5</sup>，0 ≤ c, d ≤ 10<sup>9</sup>，0 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>。<br>输入格式：第一行五个整数：n, k, m, c, d；第二行n个整数a<sub>i</sub>。</p>\n<h3 id=\"分析思路：\"><a href=\"#分析思路：\" class=\"headerlink\" title=\"分析思路：\"></a>分析思路：</h3><p>说实话，看到第k大，俺就想平衡树，结果呢，是个二分…<br>首先，答案是唯一确定的，并且根据数据范围一定属于[0, 10<sup>18</sup>] (其实应该比10<sup>18</sup>要小,但这样更保险)，我们二分的根据就是可以讲这个区间划分为小于等于答案和大于答案两部分。<br>从时间复杂度上我们不难看出，如果写二分的话，那么check中的时间复杂度应该是O(n)的，显然很难想…<br>因为这个A搞了个差分，所以就不免往差分和前缀和这里去想了，结果还真能做；首先check返回true时表示传入的mid小于等于答案，即在最优的位置加上这个等差数列之后，大于等于mid的数的个数大于等于k，反之则为false；扫描一遍序列a，如果a<sub>i</sub>≥mid则cnt++，反之，尝试寻找一段有效区间(指首项允许加在的位置上)使得首项加在该区间任意位置后，可以使得该项大于等于mid，而记录这个区间，我们采用差分的方式，即构造一个差分数组s，令区间[l, r]的左s[l]++,右s[r + 1]–，这样再重新扫描一遍就可以得到，当等差数列加在最优位置后，可以多出多少个大于mid的数，再加上原来的cnt，最后与k比较，这样就线性的完成了这项工作。<br>然后这个题就可以A掉了吧…</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n\ntypedef long long ll;\n\nconst int N &#x3D; 200010;\nconst ll MAX &#x3D; 1e18;\n\nint n, k, m;\nll c, d;\nll a[N];\nint s[N];\n\nbool check(ll x)&#123;\n    for (int i &#x3D; 0; i &lt;&#x3D; n + 1; i ++ )\n        s[i] &#x3D; 0;\n    int cnt &#x3D; 0, l, r;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        if (a[i] &gt;&#x3D; x)\n            cnt++;\n        else&#123;\n            &#x2F;&#x2F;首项最远的位置\n            l &#x3D; i - m + 1;\n            &#x2F;&#x2F;寻找右边界\n            if (d !&#x3D; 0)\n                r &#x3D; std::min(int(i - ceil(double(x - a[i] - c) &#x2F; d)), i);\n            else if (a[i] + c &gt;&#x3D; x)\n                r &#x3D; i;\n            else\n                r &#x3D; -0x3f3f3f3f;\n            &#x2F;&#x2F;如果区间存在则记录，如果l&gt;r表示数列最大项加上也不够\n            if (l &lt;&#x3D; r)\n                s[std::max(1, l)]++, s[std::max(0, r) + 1]--;\n        &#125;\n    \n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;\n        s[i] +&#x3D; s[i - 1];\n        if (s[i] + cnt &gt;&#x3D; k)\n            return true;\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d%d%lld%lld&quot;, &amp;n, &amp;k, &amp;m, &amp;c, &amp;d);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        scanf(&quot;%lld&quot;, &amp;a[i]);\n\n    ll l &#x3D; 0, r &#x3D; MAX, mid;\n    while (l &lt; r)&#123;\n        mid &#x3D; l + r + 1 &gt;&gt; 1;\n        if (check(mid))\n            l &#x3D; mid;\n        else\n            r &#x3D; mid - 1;\n    &#125;\n\n    printf(&quot;%lld\\n&quot;, l);\n&#125;</code></pre>","feature":false,"text":"测试链接：D.Chat Program中文题面在这里面找 题目大意：题面很长，说人话就是，给一个长n的序列a，另外给出k,m,c,d四个整数，我们可以选择序列中的一个位置p(1 ≤ p ≤ n - m + 1)，并对于所有0 ≤ i &lt; m，将ap+i增加(c + di)，...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":22,"path":"api/categories/题记.json"},{"name":"icpc","slug":"题记/icpc","count":1,"path":"api/categories/题记/icpc.json"},{"name":"The 2022 ICPC Asia Nanjing Regional Contest","slug":"题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest","count":1,"path":"api/categories/题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest.json"},{"name":"差分","slug":"题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest/差分","count":1,"path":"api/categories/题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest/差分.json"},{"name":"二分答案","slug":"题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest/差分/二分答案","count":1,"path":"api/categories/题记/icpc/The-2022-ICPC-Asia-Nanjing-Regional-Contest/差分/二分答案.json"}],"tags":[{"name":"题记","slug":"题记","count":22,"path":"api/tags/题记.json"},{"name":"差分","slug":"差分","count":2,"path":"api/tags/差分.json"},{"name":"icpc","slug":"icpc","count":1,"path":"api/tags/icpc.json"},{"name":"The 2022 ICPC Asia Nanjing Regional Contest","slug":"The-2022-ICPC-Asia-Nanjing-Regional-Contest","count":1,"path":"api/tags/The-2022-ICPC-Asia-Nanjing-Regional-Contest.json"},{"name":"二分答案","slug":"二分答案","count":2,"path":"api/tags/二分答案.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">测试链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">分析思路：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"线段树整理","uid":"e0aa9ca13b84c518e471c68dfb7b2c45","slug":"线段树整理","date":"2023-01-01T16:00:00.000Z","updated":"2023-01-01T16:00:00.000Z","comments":true,"path":"api/articles/线段树整理.json","keywords":"notes","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"整理","slug":"整理","count":1,"path":"api/categories/整理.json"},{"name":"线段树","slug":"整理/线段树","count":1,"path":"api/categories/整理/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":5,"path":"api/tags/线段树.json"},{"name":"整理","slug":"整理","count":1,"path":"api/tags/整理.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"CF240F.TorCoder","uid":"8f6e4acfe4f50e2d7064f00009cb5c10","slug":"CF240F.TorCoder","date":"2023-01-15T15:00:59.763Z","updated":"2023-01-27T11:24:17.806Z","comments":true,"path":"api/articles/CF240F.TorCoder.json","keywords":"notes","cover":"/images/cf.png","text":"原题链接：CF240F 题目大意：给出一个长度为n的由’a’到’z’组成的字符串，有m次操作，每次操作将[l, r]这些位置的字符进行重排，得到字典序最小的回文字符串，如果无法组成回文字符串，则操作不进行，输出操作m次后的字符串。输入输出要求：从文件 input.txt 中读入数...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"题记","slug":"题记","count":22,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#145 (Div. 1, ACM-ICPC Rules)","slug":"题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules.json"},{"name":"D2600","slug":"题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules/D2600","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules/D2600.json"},{"name":"线段树","slug":"题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules/D2600/线段树","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-145-Div-1-ACM-ICPC-Rules/D2600/线段树.json"}],"tags":[{"name":"题记","slug":"题记","count":22,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"线段树","slug":"线段树","count":5,"path":"api/tags/线段树.json"},{"name":"Codeforces Round#145 (Div. 1, ACM-ICPC Rules)","slug":"Codeforces-Round-145-Div-1-ACM-ICPC-Rules","count":1,"path":"api/tags/Codeforces-Round-145-Div-1-ACM-ICPC-Rules.json"},{"name":"D2600","slug":"D2600","count":1,"path":"api/tags/D2600.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}