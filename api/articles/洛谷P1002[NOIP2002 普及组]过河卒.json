{"title":"洛谷P1002[NOIP2002 普及组]过河卒","uid":"b48ae5252cdf21a431ed1030afed6c71","slug":"洛谷P1002[NOIP2002 普及组]过河卒","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P1002[NOIP2002 普及组]过河卒.json","keywords":"notes","cover":"/images/lg.jpg","content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://www.luogu.com.cn/problem/P1002\">LuoguP1002</a></p>\n<h3 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h3><p>就是如果可以走到点(i，j)，那么方案数f(i, j) &#x3D; f(i - 1, j) + f(i, j - 1)。<br>数据范围：1 ≤ n, m ≤ 20，0 ≤ 马的坐标 ≤ 20。</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nint cx[8] &#x3D; &#123;1, 1, 2, 2, -1, -1, -2, -2&#125;;\nint cy[8] &#x3D; &#123;2, -2, 1, -1, 2, -2, 1, -1&#125;;\n\nint main()&#123;\n    int n, m, x, y;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;\n    long long f[25][25] &#x3D; &#123;&#125;;\n    int p[25][25] &#x3D; &#123;&#125;;\n    f[2][2] &#x3D; 1;\n    p[2][2]++;\n    n +&#x3D; 2;\n    m +&#x3D; 2;\n    x +&#x3D; 2;\n    y +&#x3D; 2;\n    p[x][y]++;\n    for (int i &#x3D; 0; i &lt; 8; i++)\n        p[x + cx[i]][y + cy[i]]++;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i++)\n        for (int j &#x3D; 2; j &lt;&#x3D; m; j++)\n            if (p[i][j] &#x3D;&#x3D; 0)\n                f[i][j] &#x3D; f[i - 1][j] + f[i][j - 1];\n    cout &lt;&lt; f[n][m];\n&#125;</code></pre>","feature":false,"text":"原题链接：LuoguP1002 题目分析：就是如果可以走到点(i，j)，那么方案数f(i, j) &#x3D; f(i - 1, j) + f(i, j - 1)。数据范围：1 ≤ n, m ≤ 20，0 ≤ 马的坐标 ≤ 20。 代码如下：#include&lt;iostrea...","link":"","photos":[],"count_time":{"symbolsCount":879,"symbolsTime":"1 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":5,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷橙题","slug":"题记/洛谷/洛谷橙题","count":2,"path":"api/categories/题记/洛谷/洛谷橙题.json"},{"name":"dp","slug":"题记/洛谷/洛谷橙题/dp","count":1,"path":"api/categories/题记/洛谷/洛谷橙题/dp.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":5,"path":"api/tags/洛谷.json"},{"name":"洛谷橙题","slug":"洛谷橙题","count":2,"path":"api/tags/洛谷橙题.json"},{"name":"dp","slug":"dp","count":1,"path":"api/tags/dp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A\"><span class=\"toc-text\">题目分析：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"离散化","uid":"7f00768b865696d227f7b794a43f7717","slug":"离散化","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/离散化.json","keywords":"notes","cover":null,"text":"对于一个非常大的数据范围内，需要使用的值远远小于数据范围的时候，需要用离散化去优化，即将所有需要用到的值映射到一个小的数据范围中。其中有的题的离散化需要保序，即若x&lt;y，则离散化后x’&lt;y’也要成立；而有的题则不需要保序，可以用哈希表去进行映射操作，花费时间更少。 保...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"离散化","slug":"算法模板/离散化","count":1,"path":"api/categories/算法模板/离散化.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"离散化","slug":"离散化","count":2,"path":"api/tags/离散化.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"链表","uid":"0d5be13038d02acb3bbf4a07263c6953","slug":"链表","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/链表.json","keywords":"notes","cover":null,"text":"单链表：&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; &#x2F;&#x2F; 初始化 void init() &#123; head &#x...","link":"","photos":[],"count_time":{"symbolsCount":879,"symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"数据结构","slug":"算法模板/数据结构","count":4,"path":"api/categories/算法模板/数据结构.json"},{"name":"链表","slug":"算法模板/数据结构/链表","count":1,"path":"api/categories/算法模板/数据结构/链表.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"数据结构","slug":"数据结构","count":4,"path":"api/tags/数据结构.json"},{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}