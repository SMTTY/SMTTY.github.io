{"title":"CF1749B.Death's Blessing","uid":"ec81d70b1346c4b4569d5c4b5f32b11d","slug":"CF1749B.Death's Blessing","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/CF1749B.Death's Blessing.json","keywords":"notes","cover":"/images/cf.png","content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://codeforces.com/problemset/problem/1749/B\">CF1749B</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>游戏中，有一排怪物，他们都有一定的血量，分别为a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>，同时，每个怪物都有一个死亡祝福b<sub>i</sub>，当某一怪物被杀死后，他身旁的怪物的生命会受到死亡祝福增加(怪物站成一排，第一个和最后一个怪物不相邻)，并且当一个怪物被杀死后，整排会缩小，使得他之前的邻居变得相邻，即若这一排有三个怪物，击杀第二个怪物之后，第一第三个怪物会变得相邻；假设我们每造成一点伤害需要一秒时间，我们需要求出杀死这一排怪物最少需要多少时间。<br>总共给出t组测试数据，每组数据中给出怪物数量n，接下来第一行a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>表示每只怪物的血量，下一行b<sub>1</sub>,b<sub>2</sub>,…,b<sub>i</sub>表示每只怪物的血量。<br>数据范围：1 ≤ t ≤ 10<sup>4</sup>，1 ≤ n ≤ 2* 10<sup>5</sup>，1 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>，0 ≤ b<sub>i</sub> ≤ 10<sup>9</sup>，Σn ≤ 2*10<sup>5</sup>。</p>\n<h3 id=\"分析思路：\"><a href=\"#分析思路：\" class=\"headerlink\" title=\"分析思路：\"></a>分析思路：</h3><p>因为我们需要将这一排怪物全部击杀，所以所有的a<sub>i</sub>是我们无法避免的；再观察b<sub>i</sub>的叠加规律，首先发现，最后一只击杀的怪物的b是不需要考虑的，即不用累加，而其他怪物都会向两侧传递b<sub>i</sub>，但是在两侧的怪只能向一侧传递，并且击败他们之后，他们的邻居会重新成为排头，分析可知最佳方案应该是从两边开始打怪，并且b<sub>i</sub>最大的怪最后打；那么所需要的时间最小值就被确定为Σa<sub>i</sub> + Σb<sub>i</sub> - max(b<sub>i</sub>)。</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nint main()&#123;\n    int _;\n    cin &gt;&gt; _;\n    while (_ -- )&#123;\n        int n, m &#x3D; 0, x;\n        long long ans &#x3D; 0;\n        cin &gt;&gt; n;\n        for (int i &#x3D; 0; i &lt; n; i ++ )&#123;\n            cin &gt;&gt; x;\n            ans +&#x3D; x;\n        &#125;\n        for (int i &#x3D; 0; i &lt; n; i ++ )&#123;\n            cin &gt;&gt; x;\n            m &#x3D; max(m, x);\n            ans +&#x3D; x;\n        &#125;\n        ans -&#x3D; m;\n        cout &lt;&lt; ans &lt;&lt; endl;\n    &#125;\n&#125;</code></pre>","feature":false,"text":"原题链接：CF1749B 题目大意：游戏中，有一排怪物，他们都有一定的血量，分别为a1,a2,…,an，同时，每个怪物都有一个死亡祝福bi，当某一怪物被杀死后，他身旁的怪物的生命会受到死亡祝福增加(怪物站成一排，第一个和最后一个怪物不相邻)，并且当一个怪物被杀死后，整排会缩小，使...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Educational Codeforces Round 138 (Rated for Div. 2)","slug":"题记/Codeforces/Educational-Codeforces-Round-138-Rated-for-Div-2","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-138-Rated-for-Div-2.json"},{"name":"D900","slug":"题记/Codeforces/Educational-Codeforces-Round-138-Rated-for-Div-2/D900","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-138-Rated-for-Div-2/D900.json"},{"name":"贪心","slug":"题记/Codeforces/Educational-Codeforces-Round-138-Rated-for-Div-2/D900/贪心","count":1,"path":"api/categories/题记/Codeforces/Educational-Codeforces-Round-138-Rated-for-Div-2/D900/贪心.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"贪心","slug":"贪心","count":9,"path":"api/tags/贪心.json"},{"name":"Educational Codeforces Round 138 (Rated for Div. 2)","slug":"Educational-Codeforces-Round-138-Rated-for-Div-2","count":1,"path":"api/tags/Educational-Codeforces-Round-138-Rated-for-Div-2.json"},{"name":"D900","slug":"D900","count":1,"path":"api/tags/D900.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">分析思路：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CF1744C.Traffic Light","uid":"5329850074d4a4358b32a48b44c0c487","slug":"CF1744C.Traffic Light","date":"2022-11-07T16:00:00.000Z","updated":"2022-11-07T16:00:00.000Z","comments":true,"path":"api/articles/CF1744C.Traffic Light.json","keywords":"notes","cover":"/images/cf.png","text":"原题链接：CF1744C 题目大意：有那么有一个有大病的交通信号灯，它会按一个规律一直循环闪烁(依然还是RYG三色，且还是只有绿灯可以通行)，这个规律用一个字符串描述，如rggry，那么它的闪烁就是rggryrggry…循环往复，可以知道现在的红绿灯时什么颜色，但是不知道现在的时...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#828 (Div. 3)","slug":"题记/Codeforces/Codeforces-Round-828-Div-3","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3.json"},{"name":"D1000","slug":"题记/Codeforces/Codeforces-Round-828-Div-3/D1000","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3/D1000.json"},{"name":"双指针","slug":"题记/Codeforces/Codeforces-Round-828-Div-3/D1000/双指针","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-828-Div-3/D1000/双指针.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"D1000","slug":"D1000","count":3,"path":"api/tags/D1000.json"},{"name":"Codeforces Round#828 (Div. 3)","slug":"Codeforces-Round-828-Div-3","count":2,"path":"api/tags/Codeforces-Round-828-Div-3.json"},{"name":"双指针","slug":"双指针","count":1,"path":"api/tags/双指针.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"区间合并","uid":"e2877b7fa24b8c65939a980db8467f26","slug":"区间合并","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/区间合并.json","keywords":"notes","cover":null,"text":"非常好理解的板子，用的也非常少，就是把区间合并。 板子如下：&#x2F;&#x2F; 将所有存在交集的区间合并 typedef pair&lt;int, int&gt; PII; void merge(vector&lt;PII&gt; &amp;segs) &#123; vec...","link":"","photos":[],"count_time":{"symbolsCount":634,"symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"区间合并","slug":"算法模板/区间合并","count":1,"path":"api/categories/算法模板/区间合并.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"区间合并","slug":"区间合并","count":1,"path":"api/tags/区间合并.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}