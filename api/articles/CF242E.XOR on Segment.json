{"title":"CF242E.XOR on Segment","uid":"50b31c65d3a0ab42e18780b1693a66e7","slug":"CF242E.XOR on Segment","date":"2023-01-14T12:24:15.132Z","updated":"2023-01-14T14:06:11.537Z","comments":true,"path":"api/articles/CF242E.XOR on Segment.json","keywords":"notes","cover":"/images/cf.png","content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://codeforces.com/contest/242/problem/E\">CF242E</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>维护长度为n的序列a，并支持两张操作：</p>\n<ol>\n<li>求区间[l, r]的元素和(以op,l,r输入)</li>\n<li>把区间[l, r]的元素分别异或上x(以op,l,r,x输入)<br>输入格式：第一行一个n表示序列长度，第二行是长度为n的序列；第三行m表示操作的个数，接下来m行是操作。<br>数据范围：1 &lt;&#x3D; n &lt;&#x3D; 10<sup>5</sup>，1 &lt;&#x3D; m &lt;&#x3D; 5*10<sup>4</sup>，0 &lt;&#x3D; a<sub>i</sub> &lt;&#x3D; 10<sup>6</sup>，1 &lt;&#x3D; x &lt;&#x3D; 10<sup>6</sup>。</li>\n</ol>\n<h3 id=\"分析思路：\"><a href=\"#分析思路：\" class=\"headerlink\" title=\"分析思路：\"></a>分析思路：</h3><p>读完题很明显是个线段树，再加上异或运算，我们很容易就想到用二进制去维护每一个元素的值，那么非叶子节点的值应该等于其左右儿子的值之和，不难发现，对于加法，如果我们不进位，转化到十进制，也不会错误的，比方说(10)<sub>2</sub>+(10)<sub>2</sub>&#x3D;(100)<sub>2</sub>&#x3D;4，如果不进位则为(20)以二进制的权位相加结果仍为4，也就是说每个根节点的值可以直接每一位加和(不用考虑进位)得到。<br>再分析区间异或运算，如果某一位上^0 时显然这一位是不变的，而当某一位^1 时相当于这一位上取反，那么对于一个区间的每一个元素的同一个位置上^1 就相当于将该位置的所有0变成1、所有1变成0，换而言之交换该根节点这一位置上01的个数；有个这个结论上传和懒标记也就有了思路，上传即统计每个位置上0和1的和，懒标记则记为0、1需要取反则为1，反之为0(偶数次取反则不用取反，所以懒标记统计也用异或)。<br>对于拆位后的值，我们仍可通过权位相加法得到原值。</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N &#x3D; 100010;\n\nint n, m;\nint a[N];\nll p[21];\nstruct Node&#123;\n    int l, r;\n    int num[2][20];\n    short tag[20];\n&#125; tr[N * 4];\n&#x2F;&#x2F;tr[u]的第i位取反\ninline void swapnum(int u, int i)&#123;\n    swap(tr[u].num[0][i], tr[u].num[1][i]);\n&#125;\n&#x2F;&#x2F;上传\ninline void pushup(int u)&#123;\n    for (int i &#x3D; 0; i &lt; 20; i ++ )\n        tr[u].num[0][i] &#x3D; tr[u &lt;&lt; 1].num[0][i] + tr[u &lt;&lt; 1 | 1].num[0][i],\n        tr[u].num[1][i] &#x3D; tr[u &lt;&lt; 1].num[1][i] + tr[u &lt;&lt; 1 | 1].num[1][i];\n&#125;\n&#x2F;&#x2F;下放\ninline void pushdown(int u)&#123;\n    for (int i &#x3D; 0; i &lt; 20; i ++ )&#123;\n        if (!tr[u].tag[i])\n            continue;\n        tr[u &lt;&lt; 1].tag[i] ^&#x3D; tr[u].tag[i];\n        tr[u &lt;&lt; 1 | 1].tag[i] ^&#x3D; tr[u].tag[i];\n        swapnum(u &lt;&lt; 1, i), swapnum(u &lt;&lt; 1 | 1, i);\n        tr[u].tag[i] &#x3D; 0;\n    &#125;\n&#125;\n&#x2F;&#x2F;更新\ninline void update(int u, int x)&#123;\n    for (int i &#x3D; 0; i &lt; 20; i ++ )\n        if (x &gt;&gt; i &amp; 1)&#123;\n            tr[u].tag[i] ^&#x3D; 1;\n            swapnum(u, i);\n        &#125;\n&#125;\n&#x2F;&#x2F;求tr[u]的值\ninline ll getnum(int u)&#123;\n    ll res &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; 20; i ++ )\n        res +&#x3D;(ll) p[i] * tr[u].num[1][i];\n    return res;\n&#125;\n\nvoid build(int u, int l, int r)&#123;\n    tr[u] &#x3D; &#123;l, r&#125;;\n    if(l &#x3D;&#x3D; r)&#123;\n        for (int i &#x3D; 0; i &lt; 20; i ++ )\n            tr[u].num[a[l] &gt;&gt; i &amp; 1][i] &#x3D; 1;\n        return;\n    &#125;\n    int mid &#x3D; l + r &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);\n    pushup(u);\n&#125;\n\nvoid modify(int u, int l, int r, int x)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        update(u, x);\n    else&#123;\n        pushdown(u);\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        if (l &lt;&#x3D; mid) modify(u &lt;&lt; 1, l, r, x);\n        if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, x);\n        pushup(u);\n    &#125;\n&#125;\n\nll query(int u, int l, int r)&#123;\n    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)\n        return getnum(u);\n    else&#123;\n        pushdown(u);\n        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;\n        ll res &#x3D; 0;\n        if (l &lt;&#x3D; mid) res &#x3D; query(u &lt;&lt; 1, l, r);\n        if (r &gt; mid) res +&#x3D; query(u &lt;&lt; 1 | 1, l, r);\n        return res;\n    &#125;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        scanf(&quot;%d&quot;, &amp;a[i]);\n\n    p[0] &#x3D; 1;\n    for (int i &#x3D; 1; i &lt;&#x3D; 20; i ++ )\n        p[i] &#x3D; p[i - 1] * 2;\n\n    build(1, 1, n);\n  \n    scanf(&quot;%d&quot;, &amp;m);\n    int op, l, r, x;\n    while (m -- )&#123;\n        scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r);\n        if (op &#x3D;&#x3D; 1) printf(&quot;%lld\\n&quot;, query(1, l, r));\n        else&#123;\n            scanf(&quot;%d&quot;, &amp;x);\n            modify(1, l, r, x);\n        &#125;\n    &#125;\n&#125;</code></pre>","feature":false,"text":"原题链接：CF242E 题目大意：维护长度为n的序列a，并支持两张操作： 求区间[l, r]的元素和(以op,l,r输入) 把区间[l, r]的元素分别异或上x(以op,l,r,x输入)输入格式：第一行一个n表示序列长度，第二行是长度为n的序列；第三行m表示操作的个数，接下来m行...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"题记","slug":"题记","count":20,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":15,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#149 (Div. 2)","slug":"题记/Codeforces/Codeforces-Round-149-Div-2","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-149-Div-2.json"},{"name":"D2000","slug":"题记/Codeforces/Codeforces-Round-149-Div-2/D2000","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-149-Div-2/D2000.json"},{"name":"线段树","slug":"题记/Codeforces/Codeforces-Round-149-Div-2/D2000/线段树","count":1,"path":"api/categories/题记/Codeforces/Codeforces-Round-149-Div-2/D2000/线段树.json"}],"tags":[{"name":"题记","slug":"题记","count":20,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":15,"path":"api/tags/codeforces.json"},{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"D2000","slug":"D2000","count":2,"path":"api/tags/D2000.json"},{"name":"Codeforces Round#149 (Div. 2)","slug":"Codeforces-Round-149-Div-2","count":1,"path":"api/tags/Codeforces-Round-149-Div-2.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">分析思路：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"线段树整理","uid":"e0aa9ca13b84c518e471c68dfb7b2c45","slug":"线段树整理","date":"2023-01-01T16:00:00.000Z","updated":"2023-01-01T16:00:00.000Z","comments":true,"path":"api/articles/线段树整理.json","keywords":"notes","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"整理","slug":"整理","count":1,"path":"api/categories/整理.json"},{"name":"线段树","slug":"整理/线段树","count":1,"path":"api/categories/整理/线段树.json"}],"tags":[{"name":"线段树","slug":"线段树","count":4,"path":"api/tags/线段树.json"},{"name":"整理","slug":"整理","count":1,"path":"api/tags/整理.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"洛谷P2802回家","uid":"739a4c86892ca932c7b320c540dd8272","slug":"洛谷P2802回家","date":"2023-01-11T16:00:00.000Z","updated":"2023-01-11T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P2802回家.json","keywords":"notes","cover":"/images/lg.jpg","text":"原题链接：LuoguP2802 题目大意：在一个n*m个方格组成的矩形内，每次可以向上下左右四个方向移动一格，共有五种属性的格子：0. 障碍物（不可行走） 空地 起点 终点 带有治疗效果的空地（除了障碍物均可自由行走）刚开始时是满血6点，每移动一个需要耗费一点生命值以及一个单位时...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":20,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":5,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷橙题","slug":"题记/洛谷/洛谷橙题","count":2,"path":"api/categories/题记/洛谷/洛谷橙题.json"},{"name":"广搜","slug":"题记/洛谷/洛谷橙题/广搜","count":1,"path":"api/categories/题记/洛谷/洛谷橙题/广搜.json"}],"tags":[{"name":"题记","slug":"题记","count":20,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":5,"path":"api/tags/洛谷.json"},{"name":"洛谷橙题","slug":"洛谷橙题","count":2,"path":"api/tags/洛谷橙题.json"},{"name":"广搜","slug":"广搜","count":1,"path":"api/tags/广搜.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}