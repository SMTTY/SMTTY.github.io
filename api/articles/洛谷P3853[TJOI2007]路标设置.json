{"title":"洛谷P3853[TJOI2007]路标设置","uid":"241d076c874b2badab1c87882a2d2fef","slug":"洛谷P3853[TJOI2007]路标设置","date":"2022-11-03T16:00:00.000Z","updated":"2022-11-03T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P3853[TJOI2007]路标设置.json","keywords":"notes","cover":"/images/lg.jpg","content":"<h3 id=\"原题链接：\"><a href=\"#原题链接：\" class=\"headerlink\" title=\"原题链接：\"></a>原题链接：</h3><p><a href=\"https://www.luogu.com.cn/problem/P3853\">LuoguP3853</a></p>\n<h3 id=\"用到的知识：\"><a href=\"#用到的知识：\" class=\"headerlink\" title=\"用到的知识：\"></a>用到的知识：</h3><p><a href=\"https://smtty.github.io/post/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86\">整数二分</a></p>\n<h3 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h3><p>在一段长 L 的公路上某些地方设有 N 个路标（保证起点终点开始时都有路标），它们的位置是与起点的距离表示，但是有人还是嫌少，所以又要添加 K 个路标，路标可以添加到任意位置。<br>涉及的所有数据全部都为整数，2 ≤ N ≤ 10<sup>5</sup>，0 ≤ K ≤ 10<sup>5</sup>，0 ≤ L ≤ 10<sup>7</sup>。<br>已知：公路上相邻路标的最大距离定义为公路的空旷指数。<br>求：相邻路标求添加路标后的最小空旷指数的值。</p>\n<h3 id=\"做题历程：\"><a href=\"#做题历程：\" class=\"headerlink\" title=\"做题历程：\"></a>做题历程：</h3><h4 id=\"错误思路：\"><a href=\"#错误思路：\" class=\"headerlink\" title=\"错误思路：\"></a>错误思路：</h4><p>最开始我的想法是求出开始时全部相邻的路灯的距离，存入大根堆，然后循环K次，每次取出堆顶t，将其分为t &#x2F; 2，(t + 1) &#x2F; 2两部分后再次插入大根堆，最后的堆顶就是答案。<br>然后就是很自信的提交，就是很自信的WA。</p>\n<h4 id=\"分析错因：\"><a href=\"#分析错因：\" class=\"headerlink\" title=\"分析错因：\"></a>分析错因：</h4><p>再次分析不难发现如果某次最大距离是50，而剩余的操作次数是3次，按照上述思路，则被分为25，13，12；而不难发现分为17，17，16才是此时的最佳方案。也就是说一步一步的贪心是不够找到最小的最大值的。</p>\n<h4 id=\"正确思路：\"><a href=\"#正确思路：\" class=\"headerlink\" title=\"正确思路：\"></a>正确思路：</h4><p>再次分析，一种解决方案是（我也只能想到这种了）可以通过二分查找在[0, L]中搜索答案，而搜寻条件就是能否在K次内将每个间隔控制在mid内，如果可以则更新left坐标，否则更新right坐标，直到找到临界点，即为答案。</p>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int N &#x3D; 100010;\n\nint n, l, k;\nint a[N]; &#x2F;&#x2F; a[N]用来储存相邻路灯的距离\n\nbool check(int x)&#123;\n    int cnt &#x3D; 0;\n    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )\n        if (a[i] - a[i - 1] &gt;&#x3D; x)&#123;\n            cnt +&#x3D; (a[i] - a[i - 1]) &#x2F; x; \n            &#x2F;&#x2F; 统计如果分割至最大距离为x需要操作次数\n            if ((a[i] - a[i - 1]) % x &#x3D;&#x3D; 0) cnt--;  \n            &#x2F;&#x2F;如果刚好整除，即刚好整分，需要刨除一次多余的操作\n        &#125;\n    if (cnt &gt; k) return false;\n    return true;\n&#125;\n\nint main()&#123;\n    cin &gt;&gt; l &gt;&gt; n &gt;&gt; k;\n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )\n        cin &gt;&gt; a[i];\n    \n    int le &#x3D; 1, ri &#x3D; l + 1;\n    while (le &lt; ri)&#123;\n        if (check((le + ri) &#x2F; 2)) ri &#x3D; (le + ri) &#x2F; 2;\n        else le &#x3D; (le + ri) &#x2F; 2 + 1;\n    &#125;\n    cout &lt;&lt; le &lt;&lt; endl; &#x2F;&#x2F; 此处le &#x3D; ri 输出哪个都一样\n&#125;</code></pre>\n\n<h3 id=\"新增hack点注意：\"><a href=\"#新增hack点注意：\" class=\"headerlink\" title=\"新增hack点注意：\"></a>新增hack点注意：</h3><p>2022十月份到十一月份左右新增了一组hack数据，如果出现RE，可能是二分时左边界取0时，可能导致mid &#x3D; 0，从而除数为0。</p>\n","feature":false,"text":"原题链接：LuoguP3853 用到的知识：整数二分 题目大意：在一段长 L 的公路上某些地方设有 N 个路标（保证起点终点开始时都有路标），它们的位置是与起点的距离表示，但是有人还是嫌少，所以又要添加 K 个路标，路标可以添加到任意位置。涉及的所有数据全部都为整数，2 ≤ N ...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":5,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷绿题","slug":"题记/洛谷/洛谷绿题","count":2,"path":"api/categories/题记/洛谷/洛谷绿题.json"},{"name":"二分答案","slug":"题记/洛谷/洛谷绿题/二分答案","count":1,"path":"api/categories/题记/洛谷/洛谷绿题/二分答案.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":5,"path":"api/tags/洛谷.json"},{"name":"洛谷绿题","slug":"洛谷绿题","count":2,"path":"api/tags/洛谷绿题.json"},{"name":"二分答案","slug":"二分答案","count":2,"path":"api/tags/二分答案.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">原题链接：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%9A\"><span class=\"toc-text\">用到的知识：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">题目大意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%9A%E9%A2%98%E5%8E%86%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">做题历程：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">错误思路：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E9%94%99%E5%9B%A0%EF%BC%9A\"><span class=\"toc-text\">分析错因：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E7%A1%AE%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">正确思路：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">代码如下：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%A2%9Ehack%E7%82%B9%E6%B3%A8%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">新增hack点注意：</span></a></li></ol>","author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CF1754B.Kevin and Permutation","uid":"7c8267ca3bcbb0a1983078a7d4c8df82","slug":"CF1754B.Kevin and Permutation","date":"2022-11-04T16:00:00.000Z","updated":"2022-11-04T16:00:00.000Z","comments":true,"path":"api/articles/CF1754B.Kevin and Permutation.json","keywords":"notes","cover":"/images/cf.png","text":"原题链接：CF1754B 题目大意：总共有t组数据，每组数据给出一个n，输出一个从1到n的排列，使得min(|pi+1-pi|)最大。即：找出使任意两个数的差值的最小值最大的一个排列，如果有多种答案，输出一种即可。数据范围：1 ≤ t ≤ 100，2 ≤ n ≤ 1000。 分析...","link":"","photos":[],"count_time":{"symbolsCount":989,"symbolsTime":"1 mins."},"categories":[{"name":"题记","slug":"题记","count":23,"path":"api/categories/题记.json"},{"name":"Codeforces","slug":"题记/Codeforces","count":16,"path":"api/categories/题记/Codeforces.json"},{"name":"Codeforces Round#829 (Div.2)","slug":"题记/Codeforces/Codeforces-Round-829-Div-2","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-829-Div-2.json"},{"name":"D800","slug":"题记/Codeforces/Codeforces-Round-829-Div-2/D800","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-829-Div-2/D800.json"},{"name":"贪心","slug":"题记/Codeforces/Codeforces-Round-829-Div-2/D800/贪心","count":2,"path":"api/categories/题记/Codeforces/Codeforces-Round-829-Div-2/D800/贪心.json"}],"tags":[{"name":"题记","slug":"题记","count":23,"path":"api/tags/题记.json"},{"name":"codeforces","slug":"codeforces","count":16,"path":"api/tags/codeforces.json"},{"name":"贪心","slug":"贪心","count":9,"path":"api/tags/贪心.json"},{"name":"D800","slug":"D800","count":4,"path":"api/tags/D800.json"},{"name":"Codeforces Round#829 (Div.2)","slug":"Codeforces-Round-829-Div-2","count":2,"path":"api/tags/Codeforces-Round-829-Div-2.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"前缀和","uid":"7e125c2fcf5388ca1ef0a457d9c6ee91","slug":"前缀和","date":"2022-11-02T16:00:00.000Z","updated":"2022-11-02T16:00:00.000Z","comments":true,"path":"api/articles/前缀和.json","keywords":"notes","cover":null,"text":"前缀和可以将区间和优化成O(1)，即对于区间内的值之和，变成一个公式的计算，如一位前缀和对于[a,b]区间求和转化为S[b] - S[a - 1]. 一维前缀和板子：S[i] &#x3D; a[1] + a[2] + ... a[i] &#x2F;&#x2F;预处理 a[l] +...","link":"","photos":[],"count_time":{"symbolsCount":434,"symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"前缀和","slug":"算法模板/前缀和","count":1,"path":"api/categories/算法模板/前缀和.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"前缀和","slug":"前缀和","count":1,"path":"api/tags/前缀和.json"}],"author":{"name":"SMTTY","slug":"blog-author","avatar":"/images/url.jpg","link":"/","description":"学习笔记","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}