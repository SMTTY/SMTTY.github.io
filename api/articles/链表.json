{"title":"链表","uid":"0d5be13038d02acb3bbf4a07263c6953","slug":"链表","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/链表.json","keywords":"notes","cover":null,"content":"<h3 id=\"单链表：\"><a href=\"#单链表：\" class=\"headerlink\" title=\"单链表：\"></a>单链表：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    head &#x3D; -1;\n    idx &#x3D; 0;\n&#125;\n\n&#x2F;&#x2F; 在链表头插入一个数a\nvoid insert(int a)\n&#123;\n    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 将头结点删除，需要保证头结点存在\nvoid remove()\n&#123;\n    head &#x3D; ne[head];\n&#125;</code></pre>\n\n<h3 id=\"双链表：\"><a href=\"#双链表：\" class=\"headerlink\" title=\"双链表：\"></a>双链表：</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n&#x2F;&#x2F; 初始化\nvoid init()\n&#123;\n    &#x2F;&#x2F;0是左端点，1是右端点\n    r[0] &#x3D; 1, l[1] &#x3D; 0;\n    idx &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n&#123;\n    e[idx] &#x3D; x;\n    l[idx] &#x3D; a, r[idx] &#x3D; r[a];\n    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;\n&#125;\n\n&#x2F;&#x2F; 删除节点a\nvoid remove(int a)\n&#123;\n    l[r[a]] &#x3D; l[a];\n    r[l[a]] &#x3D; r[a];\n&#125;</code></pre>","text":"单链表：&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; &#x2F;&#x2F; 初始化 void init() &#123; head &#x...","link":"","photos":[],"count_time":{"symbolsCount":879,"symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"数据结构","slug":"算法模板/数据结构","count":4,"path":"api/categories/算法模板/数据结构.json"},{"name":"链表","slug":"算法模板/数据结构/链表","count":1,"path":"api/categories/算法模板/数据结构/链表.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"数据结构","slug":"数据结构","count":4,"path":"api/tags/数据结构.json"},{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">单链表：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">双链表：</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"洛谷P1955[NOI2015]程序自动分析","uid":"911a72b9cf1301cce1d0e6e3bd36166b","slug":"洛谷P1955[NOI2015]程序自动分析","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/洛谷P1955[NOI2015]程序自动分析.json","keywords":"notes","cover":null,"text":"原题链接LuoguP1955用到的知识：并查集、离散化 题目大意：总共有t个问题数；每次问题都是独立的，且每个问题都有若干条件，在每个问题中给出一个正整数n，代表条件的关系数，接下来的n行中每行有三个数i, j, e表示约束条件，当e为1时表示条件i &#x3D; 条件j，当e为...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"题记","slug":"题记","count":16,"path":"api/categories/题记.json"},{"name":"洛谷","slug":"题记/洛谷","count":3,"path":"api/categories/题记/洛谷.json"},{"name":"洛谷绿题","slug":"题记/洛谷/洛谷绿题","count":2,"path":"api/categories/题记/洛谷/洛谷绿题.json"},{"name":"并查集","slug":"题记/洛谷/洛谷绿题/并查集","count":1,"path":"api/categories/题记/洛谷/洛谷绿题/并查集.json"},{"name":"离散化","slug":"题记/洛谷/洛谷绿题/并查集/离散化","count":1,"path":"api/categories/题记/洛谷/洛谷绿题/并查集/离散化.json"}],"tags":[{"name":"题记","slug":"题记","count":16,"path":"api/tags/题记.json"},{"name":"洛谷","slug":"洛谷","count":3,"path":"api/tags/洛谷.json"},{"name":"洛谷绿题","slug":"洛谷绿题","count":2,"path":"api/tags/洛谷绿题.json"},{"name":"并查集","slug":"并查集","count":1,"path":"api/tags/并查集.json"},{"name":"离散化","slug":"离散化","count":2,"path":"api/tags/离散化.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"队列","uid":"1840725987698b4cef5a9ce40df0584c","slug":"队列","date":"2022-11-06T16:00:00.000Z","updated":"2022-11-06T16:00:00.000Z","comments":true,"path":"api/articles/队列.json","keywords":"notes","cover":null,"text":"普通队列：&#x2F;&#x2F; hh 表示队头，tt表示队尾 int q[N], hh &#x3D; 0, tt &#x3D; -1; &#x2F;&#x2F; 向队尾插入一个数 q[ ++ tt] &#x3D; x; &#x2F;&#x2F; 从队头弹出一个数 hh ++ ...","link":"","photos":[],"count_time":{"symbolsCount":534,"symbolsTime":"1 mins."},"categories":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/categories/算法模板.json"},{"name":"数据结构","slug":"算法模板/数据结构","count":4,"path":"api/categories/算法模板/数据结构.json"},{"name":"队列","slug":"算法模板/数据结构/队列","count":1,"path":"api/categories/算法模板/数据结构/队列.json"}],"tags":[{"name":"算法模板","slug":"算法模板","count":17,"path":"api/tags/算法模板.json"},{"name":"数据结构","slug":"数据结构","count":4,"path":"api/tags/数据结构.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}